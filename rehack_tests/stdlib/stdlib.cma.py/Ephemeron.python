caml_check_bound = empty["caml_check_bound"]
caml_make_vect = empty["caml_make_vect"]
caml_wrap_exception = empty["caml_wrap_exception"]


def call1(f, a0):
    return f(a0) if arity_test is 1 else empty["caml_call_gen"](f, [a0])


def call2(f, a0, a1):
    return f(a0, a1) if arity_test is 2 else empty["caml_call_gen"](f, [a0, a1])


def call3(f, a0, a1, a2):
    return f(a0, a1, a2) if arity_test is 3 else empty["caml_call_gen"](f, [a0, a1, a2])


def call5(f, a0, a1, a2, a3, a4):
    return (
        f(a0, a1, a2, a3, a4)
        if arity_test is 5
        else empty["caml_call_gen"](f, [a0, a1, a2, a3, a4])
    )


global_data = empty["caml_get_global_data"]()
Obj = global_data["Obj"]
Sys = global_data["Sys"]
Not_found = global_data["Not_found"]
Pervasives = global_data["Pervasives"]
Array = global_data["Array_"]
Hashtbl = global_data["Hashtbl"]
CamlinternalLazy = global_data["CamlinternalLazy"]
Random = global_data["Random"]
d = [0, 0]
c = [0, 0]
b = [0, 0]


def MakeSeeded(H):
    def power_2_above(x, n):
        x__0 = x
        while True:
            if n <= x__0:
                return x__0
            if Sys[14] < int(x__0 * 2):
                return x__0
            x__1 = int(x__0 * 2)
            x__0 = x__1
            continue

    def function_expression_236(az):
        return call1(Random[11][2], 0)

    prng = [246, function_expression_236]

    def create(opt, initial_size):
        if opt:
            sth = opt[1]
            random = sth
        else:
            random = call1(Hashtbl[17], 0)
        s = power_2_above(16, initial_size)
        if random:
            ax = empty["caml_obj_tag"](prng)
            ay = (
                prng[1]
                if 250 is ax
                else (call1(CamlinternalLazy[2], prng) if 246 is ax else prng)
            )
            seed = call1(Random[11][4], ay)
        else:
            seed = 0
        return [0, 0, caml_make_vect(s, 0), seed, s]

    def clear(h):
        h[1] = 0
        len = len(h[2])
        av = int(len + -1)
        au = 0
        if not (av < 0):
            i = au
            while True:
                caml_check_bound(h[2], i)[i + 1] = 0
                aw = int(i + 1)
                if av is not i:
                    i = aw
                    continue
                break
        return 0

    def reset(h):
        len = len(h[2])
        return (
            clear(h)
            if len is h[4]
            else (
                (0 if UnsupportedAssignOp or true else 0)
                if UnsupportedAssignOp or true
                else (0 if UnsupportedAssignOp or true else 0)
            )
        )

    def copy(h):
        aq = h[4]
        ar = h[3]
        at = call1(Array[8], h[2])
        return [0, h[1], at, ar, aq]

    def key_index(h, hkey):
        return hkey & int(len(h[2]) + -1)

    def clean(h):
        def do_bucket(param):
            param__0 = param
            while True:
                if param__0:
                    rest = param__0[3]
                    c = param__0[2]
                    hkey = param__0[1]
                    if call1(H[7], c):
                        return [0, hkey, c, do_bucket(rest)]
                    h[1] = int(h[1] + -1)
                    param__0 = rest
                    continue
                return 0

        d = h[2]
        ao = int(len(d) + -1)
        an = 0
        if not (ao < 0):
            i = an
            while True:
                d[i + 1] = do_bucket(caml_check_bound(d, i)[i + 1])
                ap = int(i + 1)
                if ao is not i:
                    i = ap
                    continue
                break
        return 0

    def resize(h):
        odata = h[2]
        osize = len(odata)
        nsize = int(osize * 2)
        clean(h)
        ah = 1 if nsize < Sys[14] else 0
        ai = (1 if int(lsr(osize, 1)) <= h[1] else 0) if ah else ah
        if ai:
            ndata = caml_make_vect(nsize, 0)
            h[2] = ndata

            def insert_bucket(param):
                if param:
                    rest = param[3]
                    data = param[2]
                    hkey = param[1]
                    insert_bucket(rest)
                    nidx = key_index(h, hkey)
                    ndata[nidx + 1] = [
                        0,
                        hkey,
                        data,
                        caml_check_bound(ndata, nidx)[nidx + 1],
                    ]
                    return 0
                return 0

            ak = int(osize + -1)
            aj = 0
            if not (ak < 0):
                i = aj
                while True:
                    insert_bucket(caml_check_bound(odata, i)[i + 1])
                    am = int(i + 1)
                    if ak is not i:
                        i = am
                        continue
                    break
            al = 0
        else:
            al = ai
        return al

    def add(h, key, info):
        hkey = call2(H[2], h[3], key)
        i = key_index(h, hkey)
        container = call2(H[1], key, info)
        bucket = [0, hkey, container, caml_check_bound(h[2], i)[i + 1]]
        caml_check_bound(h[2], i)[i + 1] = bucket
        h[1] = int(h[1] + 1)
        ag = 1 if len(h[2]) << 1 < h[1] else 0
        return resize(h) if ag else ag

    def remove(h, key):
        hkey = call2(H[2], h[3], key)

        def remove_bucket(param):
            param__0 = param
            while True:
                if param__0:
                    next = param__0[3]
                    c = param__0[2]
                    hk = param__0[1]
                    if hkey is hk:
                        match = call2(H[3], c, key)
                        continue_label = None
                        while True:
                            if match is 0:
                                h[1] = int(h[1] + -1)
                                return next
                            else:
                                if match is 1:
                                    return [0, hk, c, remove_bucket(next)]
                                else:
                                    h[1] = int(h[1] + -1)
                                    param__0 = next
                                    continue_label = "switch"
                                    break
                            break
                        if label == "switch":
                            continue
                    return [0, hk, c, remove_bucket(next)]
                return 0

        i = key_index(h, hkey)
        af = remove_bucket(caml_check_bound(h[2], i)[i + 1])
        caml_check_bound(h[2], i)[i + 1] = af
        return 0

    def find_rec(key, hkey, param):
        param__0 = param
        while True:
            if param__0:
                rest = param__0[3]
                c = param__0[2]
                hk = param__0[1]
                if hkey is hk:
                    match = call2(H[3], c, key)
                    continue_label = None
                    while True:
                        if match is 0:
                            match__0 = call1(H[4], c)
                            if match__0:
                                d = match__0[1]
                                return d
                            param__0 = rest
                            continue_label = "switch"
                            break
                        else:
                            if match is 1:
                                param__0 = rest
                                continue_label = "switch"
                                break
                            else:
                                param__0 = rest
                                continue_label = "switch"
                                break
                        break
                    if label == "switch":
                        continue
                param__0 = rest
                continue
            raise (empty["caml_wrap_thrown_exception"](Not_found))

    def find(h, key):
        hkey = call2(H[2], h[3], key)
        ae = key_index(h, hkey)
        return find_rec(key, hkey, caml_check_bound(h[2], ae)[ae + 1])

    def find_rec_opt(key, hkey, param):
        param__0 = param
        while True:
            if param__0:
                rest = param__0[3]
                c = param__0[2]
                hk = param__0[1]
                if hkey is hk:
                    match = call2(H[3], c, key)
                    continue_label = None
                    while True:
                        if match is 0:
                            d = call1(H[4], c)
                            if d:
                                return d
                            param__0 = rest
                            continue_label = "switch"
                            break
                        else:
                            if match is 1:
                                param__0 = rest
                                continue_label = "switch"
                                break
                            else:
                                param__0 = rest
                                continue_label = "switch"
                                break
                        break
                    if label == "switch":
                        continue
                param__0 = rest
                continue
            return 0

    def find_opt(h, key):
        hkey = call2(H[2], h[3], key)
        ad = key_index(h, hkey)
        return find_rec_opt(key, hkey, caml_check_bound(h[2], ad)[ad + 1])

    def find_all(h, key):
        hkey = call2(H[2], h[3], key)

        def find_in_bucket(param):
            param__0 = param
            while True:
                if param__0:
                    rest = param__0[3]
                    c = param__0[2]
                    hk = param__0[1]
                    if hkey is hk:
                        match = call2(H[3], c, key)
                        continue_label = None
                        while True:
                            if match is 0:
                                match__0 = call1(H[4], c)
                                if match__0:
                                    d = match__0[1]
                                    return [0, d, find_in_bucket(rest)]
                                param__0 = rest
                                continue_label = "switch"
                                break
                            else:
                                if match is 1:
                                    param__0 = rest
                                    continue_label = "switch"
                                    break
                                else:
                                    param__0 = rest
                                    continue_label = "switch"
                                    break
                            break
                        if label == "switch":
                            continue
                    param__0 = rest
                    continue
                return 0

        ac = key_index(h, hkey)
        return find_in_bucket(caml_check_bound(h[2], ac)[ac + 1])

    def replace(h, key, info):
        hkey = call2(H[2], h[3], key)

        def replace_bucket(param):
            param__0 = param
            while True:
                if param__0:
                    next = param__0[3]
                    c = param__0[2]
                    hk = param__0[1]
                    if hkey is hk:
                        match = call2(H[3], c, key)
                        if 0 is match:
                            return call3(H[6], c, key, info)
                        param__0 = next
                        continue
                    param__0 = next
                    continue
                raise (empty["caml_wrap_thrown_exception"](Not_found))

        i = key_index(h, hkey)
        l = caml_check_bound(h[2], i)[i + 1]
        try:
            aa = replace_bucket(l)
            return aa
        except Exception as ab:
            ab = caml_wrap_exception(ab)
            if ab is Not_found:
                container = call2(H[1], key, info)
                caml_check_bound(h[2], i)[i + 1] = [0, hkey, container, l]
                h[1] = int(h[1] + 1)
                Z = 1 if len(h[2]) << 1 < h[1] else 0
                return resize(h) if Z else Z
            raise (empty["caml_wrap_thrown_exception_reraise"](ab))

    def mem(h, key):
        hkey = call2(H[2], h[3], key)

        def mem_in_bucket(param):
            param__0 = param
            while True:
                if param__0:
                    rest = param__0[3]
                    c = param__0[2]
                    hk = param__0[1]
                    if hk is hkey:
                        match = call2(H[3], c, key)
                        if 0 is match:
                            return 1
                        param__0 = rest
                        continue
                    param__0 = rest
                    continue
                return 0

        Y = key_index(h, hkey)
        return mem_in_bucket(caml_check_bound(h[2], Y)[Y + 1])

    def iter(f, h):
        def do_bucket(param):
            param__0 = param
            while True:
                if param__0:
                    rest = param__0[3]
                    c = param__0[2]
                    match = call1(H[5], c)
                    match__0 = call1(H[4], c)
                    if match:
                        if match__0:
                            d = match__0[1]
                            k = match[1]
                            call2(f, k, d)
                            switch__0 = 1
                        else:
                            switch__0 = 0
                    else:
                        switch__0 = 0
                    switch__0
                    param__0 = rest
                    continue
                return 0

        d = h[2]
        W = int(len(d) + -1)
        V = 0
        if not (W < 0):
            i = V
            while True:
                do_bucket(caml_check_bound(d, i)[i + 1])
                X = int(i + 1)
                if W is not i:
                    i = X
                    continue
                break
        return 0

    def fold(f, h, init):
        def do_bucket(b, accu):
            b__0 = b
            accu__0 = accu
            while True:
                if b__0:
                    rest = b__0[3]
                    c = b__0[2]
                    match = call1(H[5], c)
                    match__0 = call1(H[4], c)
                    if match:
                        if match__0:
                            d = match__0[1]
                            k = match[1]
                            accu__1 = call3(f, k, d, accu__0)
                            switch__0 = 1
                        else:
                            switch__0 = 0
                    else:
                        switch__0 = 0
                    if not (switch__0):
                        accu__1 = accu__0
                    b__0 = rest
                    accu__0 = accu__1
                    continue
                return accu__0

        d = h[2]
        accu = [0, init]
        S = int(len(d) + -1)
        R = 0
        if not (S < 0):
            i = R
            while True:
                T = accu[1]
                accu[1] = do_bucket(caml_check_bound(d, i)[i + 1], T)
                U = int(i + 1)
                if S is not i:
                    i = U
                    continue
                break
        return accu[1]

    def filter_map_inplace(f, h):
        def do_bucket(param):
            param__0 = param
            while True:
                if param__0:
                    rest = param__0[3]
                    c = param__0[2]
                    hk = param__0[1]
                    match = call1(H[5], c)
                    match__0 = call1(H[4], c)
                    if match:
                        if match__0:
                            d = match__0[1]
                            k = match[1]
                            match__1 = call2(f, k, d)
                            if match__1:
                                new_d = match__1[1]
                                call3(H[6], c, k, new_d)
                                return [0, hk, c, do_bucket(rest)]
                            param__0 = rest
                            continue
                    param__0 = rest
                    continue
                return 0

        d = h[2]
        P = int(len(d) + -1)
        O = 0
        if not (P < 0):
            i = O
            while True:
                d[i + 1] = do_bucket(caml_check_bound(d, i)[i + 1])
                Q = int(i + 1)
                if P is not i:
                    i = Q
                    continue
                break
        return 0

    def length(h):
        return h[1]

    def bucket_length(accu, param):
        accu__0 = accu
        param__0 = param
        while True:
            if param__0:
                param__1 = param__0[3]
                accu__1 = int(accu__0 + 1)
                accu__0 = accu__1
                param__0 = param__1
                continue
            return accu__0

    def stats(h):
        I = h[2]
        J = 0

        def K(m, b):
            N = bucket_length(0, b)
            return call2(Pervasives[5], m, N)

        mbl = call3(Array[17], K, J, I)
        histo = caml_make_vect(int(mbl + 1), 0)
        L = h[2]

        def M(b):
            l = bucket_length(0, b)
            histo[l + 1] = int(caml_check_bound(histo, l)[l + 1] + 1)
            return 0

        call2(Array[13], M, L)
        return [0, h[1], len(h[2]), mbl, histo]

    def bucket_length_alive(accu, param):
        accu__0 = accu
        param__0 = param
        while True:
            if param__0:
                rest = param__0[3]
                c = param__0[2]
                if call1(H[7], c):
                    accu__1 = int(accu__0 + 1)
                    accu__0 = accu__1
                    param__0 = rest
                    continue
                param__0 = rest
                continue
            return accu__0

    def stats_alive(h):
        size = [0, 0]
        C = h[2]
        D = 0

        def E(m, b):
            H = bucket_length_alive(0, b)
            return call2(Pervasives[5], m, H)

        mbl = call3(Array[17], E, D, C)
        histo = caml_make_vect(int(mbl + 1), 0)
        F = h[2]

        def G(b):
            l = bucket_length_alive(0, b)
            size[1] = int(size[1] + l)
            histo[l + 1] = int(caml_check_bound(histo, l)[l + 1] + 1)
            return 0

        call2(Array[13], G, F)
        return [0, size[1], len(h[2]), mbl, histo]

    return [
        0,
        create,
        clear,
        reset,
        copy,
        add,
        remove,
        find,
        find_opt,
        find_all,
        replace,
        mem,
        iter,
        filter_map_inplace,
        fold,
        length,
        stats,
        clean,
        stats_alive,
    ]


def obj_opt(x):
    return x


def create(param):
    return call1(Obj[26][1], 1)


def get_key(t):
    return obj_opt(call2(Obj[26][3], t, 0))


def get_key_copy(t):
    return obj_opt(call2(Obj[26][4], t, 0))


def set_key(t, k):
    return call3(Obj[26][5], t, 0, k)


def unset_key(t):
    return call2(Obj[26][6], t, 0)


def check_key(t):
    return call2(Obj[26][7], t, 0)


def blit_key(t1, t2):
    return call5(Obj[26][8], t1, 0, t2, 0, 1)


def get_data(t):
    return obj_opt(call1(Obj[26][9], t))


def get_data_copy(t):
    return obj_opt(call1(Obj[26][10], t))


def set_data(t, d):
    return call2(Obj[26][11], t, d)


def unset_data(t):
    return call1(Obj[26][12], t)


def check_data(t):
    return call1(Obj[26][13], t)


def blit_data(t1, t2):
    return call2(Obj[26][14], t1, t2)


def MakeSeeded__0(H):
    def create__0(k, d):
        c = create(0)
        set_data(c, d)
        set_key(c, k)
        return c

    hash = H[2]

    def equal(c, k):
        match = get_key(c)
        if match:
            k__0 = match[1]
            return 0 if call2(H[1], k, k__0) else 1
        return 2

    def set_key_data(c, k, d):
        unset_data(c)
        set_key(c, k)
        return set_data(c, d)

    return MakeSeeded(
        [0, create__0, hash, equal, get_data, get_key, set_key_data, check_key]
    )


def Make(H):
    equal = H[1]

    def hash(seed, x):
        return call1(H[2], x)

    include = MakeSeeded__0([0, equal, hash])
    clear = include[2]
    reset = include[3]
    copy = include[4]
    add = include[5]
    remove = include[6]
    find = include[7]
    find_opt = include[8]
    find_all = include[9]
    replace = include[10]
    mem = include[11]
    iter = include[12]
    filter_map_inplace = include[13]
    fold = include[14]
    length = include[15]
    stats = include[16]
    clean = include[17]
    stats_alive = include[18]
    B = include[1]

    def create(sz):
        return call2(B, b, sz)

    return [
        0,
        create,
        clear,
        reset,
        copy,
        add,
        remove,
        find,
        find_opt,
        find_all,
        replace,
        mem,
        iter,
        filter_map_inplace,
        fold,
        length,
        stats,
        clean,
        stats_alive,
    ]


def create__0(param):
    return call1(Obj[26][1], 2)


def get_key1(t):
    return obj_opt(call2(Obj[26][3], t, 0))


def get_key1_copy(t):
    return obj_opt(call2(Obj[26][4], t, 0))


def set_key1(t, k):
    return call3(Obj[26][5], t, 0, k)


def unset_key1(t):
    return call2(Obj[26][6], t, 0)


def check_key1(t):
    return call2(Obj[26][7], t, 0)


def get_key2(t):
    return obj_opt(call2(Obj[26][3], t, 1))


def get_key2_copy(t):
    return obj_opt(call2(Obj[26][4], t, 1))


def set_key2(t, k):
    return call3(Obj[26][5], t, 1, k)


def unset_key2(t):
    return call2(Obj[26][6], t, 1)


def check_key2(t):
    return call2(Obj[26][7], t, 1)


def blit_key1(t1, t2):
    return call5(Obj[26][8], t1, 0, t2, 0, 1)


def blit_key2(t1, t2):
    return call5(Obj[26][8], t1, 1, t2, 1, 1)


def blit_key12(t1, t2):
    return call5(Obj[26][8], t1, 0, t2, 0, 2)


def get_data__0(t):
    return obj_opt(call1(Obj[26][9], t))


def get_data_copy__0(t):
    return obj_opt(call1(Obj[26][10], t))


def set_data__0(t, d):
    return call2(Obj[26][11], t, d)


def unset_data__0(t):
    return call1(Obj[26][12], t)


def check_data__0(t):
    return call1(Obj[26][13], t)


def blit_data__0(t1, t2):
    return call2(Obj[26][14], t1, t2)


def MakeSeeded__1(H1, H2):
    def create(param, d):
        k2 = param[2]
        k1 = param[1]
        c = create__0(0)
        set_data__0(c, d)
        set_key1(c, k1)
        set_key2(c, k2)
        return c

    def hash(seed, param):
        k2 = param[2]
        k1 = param[1]
        A = int(call2(H2[2], seed, k2) * 65599)
        return int(call2(H1[2], seed, k1) + A)

    def equal(c, param):
        k2 = param[2]
        k1 = param[1]
        match = get_key1(c)
        match__0 = get_key2(c)
        if match:
            if match__0:
                k2__0 = match__0[1]
                k1__0 = match[1]
                if call2(H1[1], k1, k1__0):
                    if call2(H2[1], k2, k2__0):
                        return 0
                return 1
        return 2

    def get_key(c):
        match = get_key1(c)
        match__0 = get_key2(c)
        if match:
            if match__0:
                k2 = match__0[1]
                k1 = match[1]
                return [0, [0, k1, k2]]
        return 0

    def set_key_data(c, param, d):
        k2 = param[2]
        k1 = param[1]
        unset_data__0(c)
        set_key1(c, k1)
        set_key2(c, k2)
        return set_data__0(c, d)

    def check_key(c):
        z = check_key1(c)
        return check_key2(c) if z else z

    return MakeSeeded(
        [0, create, hash, equal, get_data__0, get_key, set_key_data, check_key]
    )


def Make__0(H1, H2):
    equal = H2[1]

    def hash(seed, x):
        return call1(H2[2], x)

    equal__0 = H1[1]
    v = [0, equal, hash]

    def hash__0(seed, x):
        return call1(H1[2], x)

    w = [0, equal__0, hash__0]

    def function_expression_237(y):
        return MakeSeeded__1(w, y)

    include = function_expression_237(v)
    clear = include[2]
    reset = include[3]
    copy = include[4]
    add = include[5]
    remove = include[6]
    find = include[7]
    find_opt = include[8]
    find_all = include[9]
    replace = include[10]
    mem = include[11]
    iter = include[12]
    filter_map_inplace = include[13]
    fold = include[14]
    length = include[15]
    stats = include[16]
    clean = include[17]
    stats_alive = include[18]
    x = include[1]

    def create(sz):
        return call2(x, c, sz)

    return [
        0,
        create,
        clear,
        reset,
        copy,
        add,
        remove,
        find,
        find_opt,
        find_all,
        replace,
        mem,
        iter,
        filter_map_inplace,
        fold,
        length,
        stats,
        clean,
        stats_alive,
    ]


def create__1(n):
    return call1(Obj[26][1], n)


def length(k):
    return call1(Obj[26][2], k)


def get_key__0(t, n):
    return obj_opt(call2(Obj[26][3], t, n))


def get_key_copy__0(t, n):
    return obj_opt(call2(Obj[26][4], t, n))


def set_key__0(t, n, k):
    return call3(Obj[26][5], t, n, k)


def unset_key__0(t, n):
    return call2(Obj[26][6], t, n)


def check_key__0(t, n):
    return call2(Obj[26][7], t, n)


def blit_key__0(t1, o1, t2, o2, l):
    return call5(Obj[26][8], t1, o1, t2, o2, l)


def get_data__1(t):
    return obj_opt(call1(Obj[26][9], t))


def get_data_copy__1(t):
    return obj_opt(call1(Obj[26][10], t))


def set_data__1(t, d):
    return call2(Obj[26][11], t, d)


def unset_data__1(t):
    return call1(Obj[26][12], t)


def check_data__1(t):
    return call1(Obj[26][13], t)


def blit_data__1(t1, t2):
    return call2(Obj[26][14], t1, t2)


def MakeSeeded__2(H):
    def create(k, d):
        c = create__1(len(k))
        set_data__1(c, d)
        t = int(len(k) + -1)
        s = 0
        if not (t < 0):
            i = s
            while True:
                set_key__0(c, i, caml_check_bound(k, i)[i + 1])
                u = int(i + 1)
                if t is not i:
                    i = u
                    continue
                break
        return c

    def hash(seed, k):
        h = [0, 0]
        o = int(len(k) + -1)
        n = 0
        if not (o < 0):
            i = n
            while True:
                p = h[1]
                q = caml_check_bound(k, i)[i + 1]
                h[1] = int(int(call2(H[2], seed, q) * 65599) + p)
                r = int(i + 1)
                if o is not i:
                    i = r
                    continue
                break
        return h[1]

    def equal(c, k):
        len = len(k)
        len__0 = length(c)
        if len is not len__0:
            return 1

        def equal_array(k, c, i):
            i__0 = i
            while True:
                if 0 <= i__0:
                    match = get_key__0(c, i__0)
                    if match:
                        ki = match[1]
                        m = caml_check_bound(k, i__0)[i__0 + 1]
                        if call2(H[1], m, ki):
                            i__1 = int(i__0 + -1)
                            i__0 = i__1
                            continue
                        return 1
                    return 2
                return 0

        return equal_array(k, c, int(len + -1))

    def get_key(c):
        len = length(c)
        if 0 is len:
            return [0, [0]]
        match = get_key__0(c, 0)
        if match:
            k0 = match[1]

            def fill(a, i):
                i__0 = i
                while True:
                    if 1 <= i__0:
                        match = get_key__0(c, i__0)
                        if match:
                            ki = match[1]
                            caml_check_bound(a, i__0)[i__0 + 1] = ki
                            i__1 = int(i__0 + -1)
                            i__0 = i__1
                            continue
                        return 0
                    return [0, a]

            a = caml_make_vect(len, k0)
            return fill(a, int(len + -1))
        return 0

    def set_key_data(c, k, d):
        unset_data__1(c)
        k = int(len(k) + -1)
        j = 0
        if not (k < 0):
            i = j
            while True:
                set_key__0(c, i, caml_check_bound(k, i)[i + 1])
                l = int(i + 1)
                if k is not i:
                    i = l
                    continue
                break
        return set_data__1(c, d)

    def check_key(c):
        def check(c, i):
            i__0 = i
            while True:
                g = 1 if i__0 < 0 else 0
                if g:
                    h = g
                else:
                    i = check_key__0(c, i__0)
                    if i:
                        i__1 = int(i__0 + -1)
                        i__0 = i__1
                        continue
                    h = i
                return h

        return check(c, int(length(c) + -1))

    return MakeSeeded(
        [0, create, hash, equal, get_data__1, get_key, set_key_data, check_key]
    )


def Make__1(H):
    equal = H[1]

    def hash(seed, x):
        return call1(H[2], x)

    include = MakeSeeded__2([0, equal, hash])
    clear = include[2]
    reset = include[3]
    copy = include[4]
    add = include[5]
    remove = include[6]
    find = include[7]
    find_opt = include[8]
    find_all = include[9]
    replace = include[10]
    mem = include[11]
    iter = include[12]
    filter_map_inplace = include[13]
    fold = include[14]
    length = include[15]
    stats = include[16]
    clean = include[17]
    stats_alive = include[18]
    f = include[1]

    def create(sz):
        return call2(f, d, sz)

    return [
        0,
        create,
        clear,
        reset,
        copy,
        add,
        remove,
        find,
        find_opt,
        find_all,
        replace,
        mem,
        iter,
        filter_map_inplace,
        fold,
        length,
        stats,
        clean,
        stats_alive,
    ]


def function_expression_238(e):
    return MakeSeeded([0, e[3], e[1], e[2], e[5], e[4], e[6], e[7]])


Ephemeron = [
    0,
    [
        0,
        create,
        get_key,
        get_key_copy,
        set_key,
        unset_key,
        check_key,
        blit_key,
        get_data,
        get_data_copy,
        set_data,
        unset_data,
        check_data,
        blit_data,
        Make,
        MakeSeeded__0,
    ],
    [
        0,
        create__0,
        get_key1,
        get_key1_copy,
        set_key1,
        unset_key1,
        check_key1,
        get_key2,
        get_key2_copy,
        set_key2,
        unset_key2,
        check_key2,
        blit_key1,
        blit_key2,
        blit_key12,
        get_data__0,
        get_data_copy__0,
        set_data__0,
        unset_data__0,
        check_data__0,
        blit_data__0,
        Make__0,
        MakeSeeded__1,
    ],
    [
        0,
        create__1,
        get_key__0,
        get_key_copy__0,
        set_key__0,
        unset_key__0,
        check_key__0,
        blit_key__0,
        get_data__1,
        get_data_copy__1,
        set_data__1,
        unset_data__1,
        check_data__1,
        blit_data__1,
        Make__1,
        MakeSeeded__2,
    ],
    [0, function_expression_238],
]
empty["caml_register_global"](11, Ephemeron, "Ephemeron")
