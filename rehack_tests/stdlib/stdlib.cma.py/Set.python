string = empty["caml_new_string"]


def call1(f, a0):
    return f(a0) if arity_test is 1 else empty["caml_call_gen"](f, [a0])


def call2(f, a0, a1):
    return f(a0, a1) if arity_test is 2 else empty["caml_call_gen"](f, [a0, a1])


global_data = empty["caml_get_global_data"]()
cst_Set_remove_min_elt = string("Set.remove_min_elt")
cst_Set_bal = string("Set.bal")
cst_Set_bal__0 = string("Set.bal")
cst_Set_bal__1 = string("Set.bal")
cst_Set_bal__2 = string("Set.bal")
Not_found = global_data["Not_found"]
Pervasives = global_data["Pervasives"]
List = global_data["List_"]
Assert_failure = global_data["Assert_failure"]
b = [0, 0, 0, 0]
c = [0, 0, 0]
d = [0, string("set.ml"), 510, 18]


def Make(Ord):
    def height(param):
        if param:
            h = param[4]
            return h
        return 0

    def create(l, v, r):
        if l:
            h = l[4]
            hl = h
        else:
            hl = 0
        if r:
            h__0 = r[4]
            hr = h__0
        else:
            hr = 0
        af = int(hl + 1) if hr <= hl else int(hr + 1)
        return [0, l, v, r, af]

    def bal(l, v, r):
        if l:
            h = l[4]
            hl = h
        else:
            hl = 0
        if r:
            h__0 = r[4]
            hr = h__0
        else:
            hr = 0
        if int(hr + 2) < hl:
            if l:
                lr = l[3]
                lv = l[2]
                ll = l[1]
                aa = height(lr)
                if aa <= height(ll):
                    return create(ll, lv, create(lr, v, r))
                if lr:
                    lrr = lr[3]
                    lrv = lr[2]
                    lrl = lr[1]
                    ab = create(lrr, v, r)
                    return create(create(ll, lv, lrl), lrv, ab)
                return call1(Pervasives[1], cst_Set_bal)
            return call1(Pervasives[1], cst_Set_bal__0)
        if int(hl + 2) < hr:
            if r:
                rr = r[3]
                rv = r[2]
                rl = r[1]
                ac = height(rl)
                if ac <= height(rr):
                    return create(create(l, v, rl), rv, rr)
                if rl:
                    rlr = rl[3]
                    rlv = rl[2]
                    rll = rl[1]
                    ad = create(rlr, rv, rr)
                    return create(create(l, v, rll), rlv, ad)
                return call1(Pervasives[1], cst_Set_bal__1)
            return call1(Pervasives[1], cst_Set_bal__2)
        ae = int(hl + 1) if hr <= hl else int(hr + 1)
        return [0, l, v, r, ae]

    def add(x, t):
        if t:
            r = t[3]
            v = t[2]
            l = t[1]
            c = call2(Ord[1], x, v)
            if 0 is c:
                return t
            if 0 <= c:
                rr = add(x, r)
                return t if r is rr else bal(l, v, rr)
            ll = add(x, l)
            return t if l is ll else bal(ll, v, r)
        return [0, 0, x, 0, 1]

    def singleton(x):
        return [0, 0, x, 0, 1]

    def add_min_element(x, param):
        if param:
            r = param[3]
            v = param[2]
            l = param[1]
            return bal(add_min_element(x, l), v, r)
        return singleton(x)

    def add_max_element(x, param):
        if param:
            r = param[3]
            v = param[2]
            l = param[1]
            return bal(l, v, add_max_element(x, r))
        return singleton(x)

    def join(l, v, r):
        if l:
            if r:
                rh = r[4]
                rr = r[3]
                rv = r[2]
                rl = r[1]
                lh = l[4]
                lr = l[3]
                lv = l[2]
                ll = l[1]
                return (
                    bal(ll, lv, join(lr, v, r))
                    if int(rh + 2) < lh
                    else (
                        bal(join(l, v, rl), rv, rr)
                        if int(lh + 2) < rh
                        else create(l, v, r)
                    )
                )
            return add_max_element(v, l)
        return add_min_element(v, r)

    def min_elt(param):
        param__0 = param
        while True:
            if param__0:
                Z = param__0[1]
                if Z:
                    param__0 = Z
                    continue
                v = param__0[2]
                return v
            raise (empty["caml_wrap_thrown_exception"](Not_found))

    def min_elt_opt(param):
        param__0 = param
        while True:
            if param__0:
                Y = param__0[1]
                if Y:
                    param__0 = Y
                    continue
                v = param__0[2]
                return [0, v]
            return 0

    def max_elt(param):
        param__0 = param
        while True:
            if param__0:
                W = param__0[3]
                X = param__0[2]
                if W:
                    param__0 = W
                    continue
                return X
            raise (empty["caml_wrap_thrown_exception"](Not_found))

    def max_elt_opt(param):
        param__0 = param
        while True:
            if param__0:
                U = param__0[3]
                V = param__0[2]
                if U:
                    param__0 = U
                    continue
                return [0, V]
            return 0

    def remove_min_elt(param):
        if param:
            T = param[1]
            if T:
                r = param[3]
                v = param[2]
                return bal(remove_min_elt(T), v, r)
            r__0 = param[3]
            return r__0
        return call1(Pervasives[1], cst_Set_remove_min_elt)

    def merge(t, match):
        if t:
            if match:
                S = remove_min_elt(match)
                return bal(t, min_elt(match), S)
            return t
        return match

    def concat(t, match):
        if t:
            if match:
                R = remove_min_elt(match)
                return join(t, min_elt(match), R)
            return t
        return match

    def split(x, param):
        if param:
            r = param[3]
            v = param[2]
            l = param[1]
            c = call2(Ord[1], x, v)
            if 0 is c:
                return [0, l, 1, r]
            if 0 <= c:
                match = split(x, r)
                rr = match[3]
                pres = match[2]
                lr = match[1]
                return [0, join(l, v, lr), pres, rr]
            match__0 = split(x, l)
            rl = match__0[3]
            pres__0 = match__0[2]
            ll = match__0[1]
            return [0, ll, pres__0, join(rl, v, r)]
        return b

    empty = 0

    def is_empty(param):
        return 0 if param else 1

    def mem(x, param):
        param__0 = param
        while True:
            if param__0:
                r = param__0[3]
                v = param__0[2]
                l = param__0[1]
                c = call2(Ord[1], x, v)
                Q = 1 if 0 is c else 0
                if Q:
                    return Q
                param__1 = r if 0 <= c else l
                param__0 = param__1
                continue
            return 0

    def remove(x, t):
        if t:
            r = t[3]
            v = t[2]
            l = t[1]
            c = call2(Ord[1], x, v)
            if 0 is c:
                return merge(l, r)
            if 0 <= c:
                rr = remove(x, r)
                return t if r is rr else bal(l, v, rr)
            ll = remove(x, l)
            return t if l is ll else bal(ll, v, r)
        return 0

    def union(t1, match):
        if t1:
            if match:
                h2 = match[4]
                r2 = match[3]
                v2 = match[2]
                l2 = match[1]
                h1 = t1[4]
                r1 = t1[3]
                v1 = t1[2]
                l1 = t1[1]
                if h2 <= h1:
                    if 1 is h2:
                        return add(v2, t1)
                    match__0 = split(v1, match)
                    r2__0 = match__0[3]
                    l2__0 = match__0[1]
                    O = union(r1, r2__0)
                    return join(union(l1, l2__0), v1, O)
                if 1 is h1:
                    return add(v1, match)
                match__1 = split(v2, t1)
                r1__0 = match__1[3]
                l1__0 = match__1[1]
                P = union(r1__0, r2)
                return join(union(l1__0, l2), v2, P)
            return t1
        return match

    def inter(s1, match):
        if s1:
            if match:
                r1 = s1[3]
                v1 = s1[2]
                l1 = s1[1]
                K = split(v1, match)
                L = K[1]
                if 0 is K[2]:
                    r2 = K[3]
                    M = inter(r1, r2)
                    return concat(inter(l1, L), M)
                r2__0 = K[3]
                N = inter(r1, r2__0)
                return join(inter(l1, L), v1, N)
            return 0
        return 0

    def diff(t1, match):
        if t1:
            if match:
                r1 = t1[3]
                v1 = t1[2]
                l1 = t1[1]
                G = split(v1, match)
                H = G[1]
                if 0 is G[2]:
                    r2 = G[3]
                    I = diff(r1, r2)
                    return join(diff(l1, H), v1, I)
                r2__0 = G[3]
                J = diff(r1, r2__0)
                return concat(diff(l1, H), J)
            return t1
        return 0

    def cons_enum(s, e):
        s__0 = s
        e__0 = e
        while True:
            if s__0:
                r = s__0[3]
                v = s__0[2]
                s__1 = s__0[1]
                e__1 = [0, v, r, e__0]
                s__0 = s__1
                e__0 = e__1
                continue
            return e__0

    def compare_aux(e1, e2):
        e1__0 = e1
        e2__0 = e2
        while True:
            if e1__0:
                if e2__0:
                    e2__1 = e2__0[3]
                    r2 = e2__0[2]
                    v2 = e2__0[1]
                    e1__1 = e1__0[3]
                    r1 = e1__0[2]
                    v1 = e1__0[1]
                    c = call2(Ord[1], v1, v2)
                    if 0 is c:
                        e2__2 = cons_enum(r2, e2__1)
                        e1__2 = cons_enum(r1, e1__1)
                        e1__0 = e1__2
                        e2__0 = e2__2
                        continue
                    return c
                return 1
            return -1 if e2__0 else 0

    def compare(s1, s2):
        F = cons_enum(s2, 0)
        return compare_aux(cons_enum(s1, 0), F)

    def equal(s1, s2):
        return 1 if 0 is compare(s1, s2) else 0

    def subset(s1, s2):
        s1__0 = s1
        s2__0 = s2
        while True:
            if s1__0:
                if s2__0:
                    r2 = s2__0[3]
                    v2 = s2__0[2]
                    l2 = s2__0[1]
                    r1 = s1__0[3]
                    v1 = s1__0[2]
                    l1 = s1__0[1]
                    c = call2(Ord[1], v1, v2)
                    if 0 is c:
                        C = subset(l1, l2)
                        if C:
                            s1__0 = r1
                            s2__0 = r2
                            continue
                        return C
                    if 0 <= c:
                        D = subset([0, 0, v1, r1, 0], r2)
                        if D:
                            s1__0 = l1
                            continue
                        return D
                    E = subset([0, l1, v1, 0, 0], l2)
                    if E:
                        s1__0 = r1
                        continue
                    return E
                return 0
            return 1

    def iter(f, param):
        param__0 = param
        while True:
            if param__0:
                param__1 = param__0[3]
                v = param__0[2]
                l = param__0[1]
                iter(f, l)
                call1(f, v)
                param__0 = param__1
                continue
            return 0

    def fold(f, s, accu):
        s__0 = s
        accu__0 = accu
        while True:
            if s__0:
                s__1 = s__0[3]
                v = s__0[2]
                l = s__0[1]
                accu__1 = call2(f, v, fold(f, l, accu__0))
                s__0 = s__1
                accu__0 = accu__1
                continue
            return accu__0

    def for_all(p, param):
        param__0 = param
        while True:
            if param__0:
                r = param__0[3]
                v = param__0[2]
                l = param__0[1]
                z = call1(p, v)
                if z:
                    A = for_all(p, l)
                    if A:
                        param__0 = r
                        continue
                    B = A
                else:
                    B = z
                return B
            return 1

    def exists(p, param):
        param__0 = param
        while True:
            if param__0:
                r = param__0[3]
                v = param__0[2]
                l = param__0[1]
                w = call1(p, v)
                if w:
                    x = w
                else:
                    y = exists(p, l)
                    if not (y):
                        param__0 = r
                        continue
                    x = y
                return x
            return 0

    def filter(p, t):
        if t:
            r = t[3]
            v = t[2]
            l = t[1]
            l__0 = filter(p, l)
            pv = call1(p, v)
            r__0 = filter(p, r)
            if pv:
                if l is l__0:
                    if r is r__0:
                        return t
                return join(l__0, v, r__0)
            return concat(l__0, r__0)
        return 0

    def partition(p, param):
        if param:
            r = param[3]
            v = param[2]
            l = param[1]
            match = partition(p, l)
            lf = match[2]
            lt = match[1]
            pv = call1(p, v)
            match__0 = partition(p, r)
            rf = match__0[2]
            rt = match__0[1]
            if pv:
                u = concat(lf, rf)
                return [0, join(lt, v, rt), u]
            v = join(lf, v, rf)
            return [0, concat(lt, rt), v]
        return c

    def cardinal(param):
        if param:
            r = param[3]
            l = param[1]
            t = cardinal(r)
            return int(int(cardinal(l) + 1) + t)
        return 0

    def elements_aux(accu, param):
        accu__0 = accu
        param__0 = param
        while True:
            if param__0:
                r = param__0[3]
                v = param__0[2]
                param__1 = param__0[1]
                accu__1 = [0, v, elements_aux(accu__0, r)]
                accu__0 = accu__1
                param__0 = param__1
                continue
            return accu__0

    def elements(s):
        return elements_aux(0, s)

    def find(x, param):
        param__0 = param
        while True:
            if param__0:
                r = param__0[3]
                v = param__0[2]
                l = param__0[1]
                c = call2(Ord[1], x, v)
                if 0 is c:
                    return v
                param__1 = r if 0 <= c else l
                param__0 = param__1
                continue
            raise (empty["caml_wrap_thrown_exception"](Not_found))

    def find_first_aux(v0, f, param):
        v0__0 = v0
        param__0 = param
        while True:
            if param__0:
                r = param__0[3]
                v = param__0[2]
                l = param__0[1]
                if call1(f, v):
                    v0__0 = v
                    param__0 = l
                    continue
                param__0 = r
                continue
            return v0__0

    def find_first(f, param):
        param__0 = param
        while True:
            if param__0:
                r = param__0[3]
                v = param__0[2]
                l = param__0[1]
                if call1(f, v):
                    return find_first_aux(v, f, l)
                param__0 = r
                continue
            raise (empty["caml_wrap_thrown_exception"](Not_found))

    def find_first_opt_aux(v0, f, param):
        v0__0 = v0
        param__0 = param
        while True:
            if param__0:
                r = param__0[3]
                v = param__0[2]
                l = param__0[1]
                if call1(f, v):
                    v0__0 = v
                    param__0 = l
                    continue
                param__0 = r
                continue
            return [0, v0__0]

    def find_first_opt(f, param):
        param__0 = param
        while True:
            if param__0:
                r = param__0[3]
                v = param__0[2]
                l = param__0[1]
                if call1(f, v):
                    return find_first_opt_aux(v, f, l)
                param__0 = r
                continue
            return 0

    def find_last_aux(v0, f, param):
        v0__0 = v0
        param__0 = param
        while True:
            if param__0:
                r = param__0[3]
                v = param__0[2]
                l = param__0[1]
                if call1(f, v):
                    v0__0 = v
                    param__0 = r
                    continue
                param__0 = l
                continue
            return v0__0

    def find_last(f, param):
        param__0 = param
        while True:
            if param__0:
                r = param__0[3]
                v = param__0[2]
                l = param__0[1]
                if call1(f, v):
                    return find_last_aux(v, f, r)
                param__0 = l
                continue
            raise (empty["caml_wrap_thrown_exception"](Not_found))

    def find_last_opt_aux(v0, f, param):
        v0__0 = v0
        param__0 = param
        while True:
            if param__0:
                r = param__0[3]
                v = param__0[2]
                l = param__0[1]
                if call1(f, v):
                    v0__0 = v
                    param__0 = r
                    continue
                param__0 = l
                continue
            return [0, v0__0]

    def find_last_opt(f, param):
        param__0 = param
        while True:
            if param__0:
                r = param__0[3]
                v = param__0[2]
                l = param__0[1]
                if call1(f, v):
                    return find_last_opt_aux(v, f, r)
                param__0 = l
                continue
            return 0

    def find_opt(x, param):
        param__0 = param
        while True:
            if param__0:
                r = param__0[3]
                v = param__0[2]
                l = param__0[1]
                c = call2(Ord[1], x, v)
                if 0 is c:
                    return [0, v]
                param__1 = r if 0 <= c else l
                param__0 = param__1
                continue
            return 0

    def try_join(l, v, r):
        if 0 is l:
            switch__0 = 0
        else:
            s = max_elt(l)
            switch__0 = 1 if 0 <= call2(Ord[1], s, v) else 0
        if not (switch__0):
            if 0 is r:
                switch__1 = 0
            else:
                r = min_elt(r)
                switch__1 = 1 if 0 <= call2(Ord[1], v, r) else 0
            if not (switch__1):
                return join(l, v, r)
        return union(l, add(v, r))

    def map(f, t):
        if t:
            r = t[3]
            v = t[2]
            l = t[1]
            l__0 = map(f, l)
            v__0 = call1(f, v)
            r__0 = map(f, r)
            if l is l__0:
                if v is v__0:
                    if r is r__0:
                        return t
            return try_join(l__0, v__0, r__0)
        return 0

    def of_sorted_list(l):
        def sub(n, l):
            if not (3 < lsr(n, 0)):
                while True:
                    if n is 0:
                        return [0, 0, l]
                    else:
                        if n is 1:
                            if l:
                                l__3 = l[2]
                                x0 = l[1]
                                return [0, [0, 0, x0, 0, 1], l__3]
                            break
                        else:
                            if n is 2:
                                if l:
                                    o = l[2]
                                    if o:
                                        l__4 = o[2]
                                        x1 = o[1]
                                        x0__0 = l[1]
                                        return [
                                            0,
                                            [0, [0, 0, x0__0, 0, 1], x1, 0, 2],
                                            l__4,
                                        ]
                                break
                            else:
                                if l:
                                    p = l[2]
                                    if p:
                                        q = p[2]
                                        if q:
                                            l__5 = q[2]
                                            x2 = q[1]
                                            x1__0 = p[1]
                                            x0__1 = l[1]
                                            return [
                                                0,
                                                [
                                                    0,
                                                    [0, 0, x0__1, 0, 1],
                                                    x1__0,
                                                    [0, 0, x2, 0, 1],
                                                    2,
                                                ],
                                                l__5,
                                            ]
                    break
            nl = int(n / 2)
            match = sub(nl, l)
            l__0 = match[2]
            left = match[1]
            if l__0:
                l__1 = l__0[2]
                mid = l__0[1]
                match__0 = sub(int(int(n - nl) + -1), l__1)
                l__2 = match__0[2]
                right = match__0[1]
                return [0, create(left, mid, right), l__2]
            raise (empty["caml_wrap_thrown_exception"]([0, Assert_failure, d]))

        return sub(call1(List[1], l), l)[1]

    def of_list(l):
        if l:
            g = l[2]
            h = l[1]
            if g:
                i = g[2]
                j = g[1]
                if i:
                    k = i[2]
                    l = i[1]
                    if k:
                        m = k[2]
                        n = k[1]
                        if m:
                            if m[2]:
                                return of_sorted_list(call2(List[51], Ord[1], l))
                            x4 = m[1]
                            return add(x4, add(n, add(l, add(j, singleton(h)))))
                        return add(n, add(l, add(j, singleton(h))))
                    return add(l, add(j, singleton(h)))
                return add(j, singleton(h))
            return singleton(h)
        return empty

    return [
        0,
        height,
        create,
        bal,
        add,
        singleton,
        add_min_element,
        add_max_element,
        join,
        min_elt,
        min_elt_opt,
        max_elt,
        max_elt_opt,
        remove_min_elt,
        merge,
        concat,
        split,
        empty,
        is_empty,
        mem,
        remove,
        union,
        inter,
        diff,
        cons_enum,
        compare_aux,
        compare,
        equal,
        subset,
        iter,
        fold,
        for_all,
        exists,
        filter,
        partition,
        cardinal,
        elements_aux,
        elements,
        min_elt,
        min_elt_opt,
        find,
        find_first_aux,
        find_first,
        find_first_opt_aux,
        find_first_opt,
        find_last_aux,
        find_last,
        find_last_opt_aux,
        find_last_opt,
        find_opt,
        try_join,
        map,
        of_sorted_list,
        of_list,
    ]


def function_expression_21(e):
    f = Make(e)
    return [
        0,
        f[17],
        f[18],
        f[19],
        f[4],
        f[5],
        f[20],
        f[21],
        f[22],
        f[23],
        f[26],
        f[27],
        f[28],
        f[29],
        f[51],
        f[30],
        f[31],
        f[32],
        f[33],
        f[34],
        f[35],
        f[37],
        f[9],
        f[10],
        f[11],
        f[12],
        f[38],
        f[39],
        f[16],
        f[40],
        f[49],
        f[42],
        f[44],
        f[46],
        f[48],
        f[53],
    ]


Set = [0, function_expression_21]
empty["caml_register_global"](12, Set, "Set")
