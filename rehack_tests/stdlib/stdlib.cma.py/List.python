caml_compare = empty["caml_compare"]
string = empty["caml_new_string"]


def call1(f, a0):
    return f(a0) if arity_test is 1 else empty["caml_call_gen"](f, [a0])


def call2(f, a0, a1):
    return f(a0, a1) if arity_test is 2 else empty["caml_call_gen"](f, [a0, a1])


def call3(f, a0, a1, a2):
    return f(a0, a1, a2) if arity_test is 3 else empty["caml_call_gen"](f, [a0, a1, a2])


global_data = empty["caml_get_global_data"]()
cst_List_map2 = string("List.map2")
cst_List_iter2 = string("List.iter2")
cst_List_fold_left2 = string("List.fold_left2")
cst_List_fold_right2 = string("List.fold_right2")
cst_List_for_all2 = string("List.for_all2")
cst_List_exists2 = string("List.exists2")
cst_List_combine = string("List.combine")
cst_List_rev_map2 = string("List.rev_map2")
cst_List_init = string("List.init")
cst_List_nth__0 = string("List.nth")
cst_nth = string("nth")
cst_List_nth = string("List.nth")
cst_tl = string("tl")
cst_hd = string("hd")
Pervasives = global_data["Pervasives"]
Not_found = global_data["Not_found"]
Assert_failure = global_data["Assert_failure"]
d = [0, 0, 0]
e = [0, string("list.ml"), 262, 11]


def length_aux(len, param):
    len__0 = len
    param__0 = param
    while True:
        if param__0:
            param__1 = param__0[2]
            len__1 = int(len__0 + 1)
            len__0 = len__1
            param__0 = param__1
            continue
        return len__0


def length(l):
    return length_aux(0, l)


def cons(a, l):
    return [0, a, l]


def hd(param):
    if param:
        a = param[1]
        return a
    return call1(Pervasives[2], cst_hd)


def tl(param):
    if param:
        l = param[2]
        return l
    return call1(Pervasives[2], cst_tl)


def nth(l, n):
    if 0 <= n:

        def nth_aux(l, n):
            l__0 = l
            n__0 = n
            while True:
                if l__0:
                    l__1 = l__0[2]
                    a = l__0[1]
                    if 0 is n__0:
                        return a
                    n__1 = int(n__0 + -1)
                    l__0 = l__1
                    n__0 = n__1
                    continue
                return call1(Pervasives[2], cst_nth)

        return nth_aux(l, n)
    return call1(Pervasives[1], cst_List_nth)


def nth_opt(l, n):
    if 0 <= n:

        def nth_aux(l, n):
            l__0 = l
            n__0 = n
            while True:
                if l__0:
                    l__1 = l__0[2]
                    a = l__0[1]
                    if 0 is n__0:
                        return [0, a]
                    n__1 = int(n__0 + -1)
                    l__0 = l__1
                    n__0 = n__1
                    continue
                return 0

        return nth_aux(l, n)
    return call1(Pervasives[1], cst_List_nth__0)


append = Pervasives[25]


def rev_append(l1, l2):
    l1__0 = l1
    l2__0 = l2
    while True:
        if l1__0:
            l1__1 = l1__0[2]
            a = l1__0[1]
            l2__1 = [0, a, l2__0]
            l1__0 = l1__1
            l2__0 = l2__1
            continue
        return l2__0


def rev(l):
    return rev_append(l, 0)


def init_tailrec_aux(acc, i, n, f):
    acc__0 = acc
    i__0 = i
    while True:
        if n <= i__0:
            return acc__0
        i__1 = int(i__0 + 1)
        acc__1 = [0, call1(f, i__0), acc__0]
        acc__0 = acc__1
        i__0 = i__1
        continue


def init_aux(i, n, f):
    if n <= i:
        return 0
    r = call1(f, i)
    return [0, r, init_aux(int(i + 1), n, f)]


def init(len, f):
    return (
        (rev(init_tailrec_aux(0, 0, len, f)) if 10000 < len else init_aux(0, len, f))
        if 0 <= len
        else call1(Pervasives[1], cst_List_init)
    )


def flatten(param):
    if param:
        r = param[2]
        l = param[1]
        C = flatten(r)
        return call2(Pervasives[25], l, C)
    return 0


def map(f, param):
    if param:
        l = param[2]
        a = param[1]
        r = call1(f, a)
        return [0, r, map(f, l)]
    return 0


def b(i, f, param):
    if param:
        l = param[2]
        a = param[1]
        r = call2(f, i, a)
        return [0, r, b(int(i + 1), f, l)]
    return 0


def mapi(f, l):
    return b(0, f, l)


def rev_map(f, l):
    def rmap_f(accu, param):
        accu__0 = accu
        param__0 = param
        while True:
            if param__0:
                param__1 = param__0[2]
                a = param__0[1]
                accu__1 = [0, call1(f, a), accu__0]
                accu__0 = accu__1
                param__0 = param__1
                continue
            return accu__0

    return rmap_f(0, l)


def iter(f, param):
    param__0 = param
    while True:
        if param__0:
            param__1 = param__0[2]
            a = param__0[1]
            call1(f, a)
            param__0 = param__1
            continue
        return 0


def c(i, f, param):
    i__0 = i
    param__0 = param
    while True:
        if param__0:
            param__1 = param__0[2]
            a = param__0[1]
            call2(f, i__0, a)
            i__1 = int(i__0 + 1)
            i__0 = i__1
            param__0 = param__1
            continue
        return 0


def iteri(f, l):
    return c(0, f, l)


def fold_left(f, accu, l):
    accu__0 = accu
    l__0 = l
    while True:
        if l__0:
            l__1 = l__0[2]
            a = l__0[1]
            accu__1 = call2(f, accu__0, a)
            accu__0 = accu__1
            l__0 = l__1
            continue
        return accu__0


def fold_right(f, l, accu):
    if l:
        l__0 = l[2]
        a = l[1]
        return call2(f, a, fold_right(f, l__0, accu))
    return accu


def map2(f, l1, l2):
    if l1:
        if l2:
            l2__0 = l2[2]
            a2 = l2[1]
            l1__0 = l1[2]
            a1 = l1[1]
            r = call2(f, a1, a2)
            return [0, r, map2(f, l1__0, l2__0)]
    else:
        if not (l2):
            return 0
    return call1(Pervasives[1], cst_List_map2)


def rev_map2(f, l1, l2):
    def rmap2_f(accu, l1, l2):
        accu__0 = accu
        l1__0 = l1
        l2__0 = l2
        while True:
            if l1__0:
                if l2__0:
                    l2__1 = l2__0[2]
                    a2 = l2__0[1]
                    l1__1 = l1__0[2]
                    a1 = l1__0[1]
                    accu__1 = [0, call2(f, a1, a2), accu__0]
                    accu__0 = accu__1
                    l1__0 = l1__1
                    l2__0 = l2__1
                    continue
            else:
                if not (l2__0):
                    return accu__0
            return call1(Pervasives[1], cst_List_rev_map2)

    return rmap2_f(0, l1, l2)


def iter2(f, l1, l2):
    l1__0 = l1
    l2__0 = l2
    while True:
        if l1__0:
            if l2__0:
                l2__1 = l2__0[2]
                a2 = l2__0[1]
                l1__1 = l1__0[2]
                a1 = l1__0[1]
                call2(f, a1, a2)
                l1__0 = l1__1
                l2__0 = l2__1
                continue
        else:
            if not (l2__0):
                return 0
        return call1(Pervasives[1], cst_List_iter2)


def fold_left2(f, accu, l1, l2):
    accu__0 = accu
    l1__0 = l1
    l2__0 = l2
    while True:
        if l1__0:
            if l2__0:
                l2__1 = l2__0[2]
                a2 = l2__0[1]
                l1__1 = l1__0[2]
                a1 = l1__0[1]
                accu__1 = call3(f, accu__0, a1, a2)
                accu__0 = accu__1
                l1__0 = l1__1
                l2__0 = l2__1
                continue
        else:
            if not (l2__0):
                return accu__0
        return call1(Pervasives[1], cst_List_fold_left2)


def fold_right2(f, l1, l2, accu):
    if l1:
        if l2:
            l2__0 = l2[2]
            a2 = l2[1]
            l1__0 = l1[2]
            a1 = l1[1]
            return call3(f, a1, a2, fold_right2(f, l1__0, l2__0, accu))
    else:
        if not (l2):
            return accu
    return call1(Pervasives[1], cst_List_fold_right2)


def for_all(p, param):
    param__0 = param
    while True:
        if param__0:
            l = param__0[2]
            a = param__0[1]
            B = call1(p, a)
            if B:
                param__0 = l
                continue
            return B
        return 1


def exists(p, param):
    param__0 = param
    while True:
        if param__0:
            l = param__0[2]
            a = param__0[1]
            A = call1(p, a)
            if A:
                return A
            param__0 = l
            continue
        return 0


def for_all2(p, l1, l2):
    l1__0 = l1
    l2__0 = l2
    while True:
        if l1__0:
            if l2__0:
                l2__1 = l2__0[2]
                a2 = l2__0[1]
                l1__1 = l1__0[2]
                a1 = l1__0[1]
                z = call2(p, a1, a2)
                if z:
                    l1__0 = l1__1
                    l2__0 = l2__1
                    continue
                return z
        else:
            if not (l2__0):
                return 1
        return call1(Pervasives[1], cst_List_for_all2)


def exists2(p, l1, l2):
    l1__0 = l1
    l2__0 = l2
    while True:
        if l1__0:
            if l2__0:
                l2__1 = l2__0[2]
                a2 = l2__0[1]
                l1__1 = l1__0[2]
                a1 = l1__0[1]
                y = call2(p, a1, a2)
                if y:
                    return y
                l1__0 = l1__1
                l2__0 = l2__1
                continue
        else:
            if not (l2__0):
                return 0
        return call1(Pervasives[1], cst_List_exists2)


def mem(x, param):
    param__0 = param
    while True:
        if param__0:
            l = param__0[2]
            a = param__0[1]
            x = 1 if 0 is caml_compare(a, x) else 0
            if x:
                return x
            param__0 = l
            continue
        return 0


def memq(x, param):
    param__0 = param
    while True:
        if param__0:
            l = param__0[2]
            a = param__0[1]
            w = 1 if a is x else 0
            if w:
                return w
            param__0 = l
            continue
        return 0


def assoc(x, param):
    param__0 = param
    while True:
        if param__0:
            l = param__0[2]
            match = param__0[1]
            b = match[2]
            a = match[1]
            if 0 is caml_compare(a, x):
                return b
            param__0 = l
            continue
        raise (empty["caml_wrap_thrown_exception"](Not_found))


def assoc_opt(x, param):
    param__0 = param
    while True:
        if param__0:
            l = param__0[2]
            match = param__0[1]
            b = match[2]
            a = match[1]
            if 0 is caml_compare(a, x):
                return [0, b]
            param__0 = l
            continue
        return 0


def assq(x, param):
    param__0 = param
    while True:
        if param__0:
            l = param__0[2]
            match = param__0[1]
            b = match[2]
            a = match[1]
            if a is x:
                return b
            param__0 = l
            continue
        raise (empty["caml_wrap_thrown_exception"](Not_found))


def assq_opt(x, param):
    param__0 = param
    while True:
        if param__0:
            l = param__0[2]
            match = param__0[1]
            b = match[2]
            a = match[1]
            if a is x:
                return [0, b]
            param__0 = l
            continue
        return 0


def mem_assoc(x, param):
    param__0 = param
    while True:
        if param__0:
            l = param__0[2]
            match = param__0[1]
            a = match[1]
            v = 1 if 0 is caml_compare(a, x) else 0
            if v:
                return v
            param__0 = l
            continue
        return 0


def mem_assq(x, param):
    param__0 = param
    while True:
        if param__0:
            l = param__0[2]
            match = param__0[1]
            a = match[1]
            u = 1 if a is x else 0
            if u:
                return u
            param__0 = l
            continue
        return 0


def remove_assoc(x, param):
    if param:
        l = param[2]
        pair = param[1]
        a = pair[1]
        return l if 0 is caml_compare(a, x) else [0, pair, remove_assoc(x, l)]
    return 0


def remove_assq(x, param):
    if param:
        l = param[2]
        pair = param[1]
        a = pair[1]
        return l if a is x else [0, pair, remove_assq(x, l)]
    return 0


def find(p, param):
    param__0 = param
    while True:
        if param__0:
            l = param__0[2]
            x = param__0[1]
            if call1(p, x):
                return x
            param__0 = l
            continue
        raise (empty["caml_wrap_thrown_exception"](Not_found))


def find_opt(p, param):
    param__0 = param
    while True:
        if param__0:
            l = param__0[2]
            x = param__0[1]
            if call1(p, x):
                return [0, x]
            param__0 = l
            continue
        return 0


def find_all(p):
    def find(accu, param):
        accu__0 = accu
        param__0 = param
        while True:
            if param__0:
                l = param__0[2]
                x = param__0[1]
                if call1(p, x):
                    accu__1 = [0, x, accu__0]
                    accu__0 = accu__1
                    param__0 = l
                    continue
                param__0 = l
                continue
            return rev(accu__0)

    s = 0

    def function_expression_6(t):
        return find(s, t)

    return function_expression_6


def partition(p, l):
    def part(yes, no, param):
        yes__0 = yes
        no__0 = no
        param__0 = param
        while True:
            if param__0:
                l = param__0[2]
                x = param__0[1]
                if call1(p, x):
                    yes__1 = [0, x, yes__0]
                    yes__0 = yes__1
                    param__0 = l
                    continue
                no__1 = [0, x, no__0]
                no__0 = no__1
                param__0 = l
                continue
            r = rev(no__0)
            return [0, rev(yes__0), r]

    return part(0, 0, l)


def split(param):
    if param:
        l = param[2]
        match = param[1]
        y = match[2]
        x = match[1]
        match__0 = split(l)
        ry = match__0[2]
        rx = match__0[1]
        return [0, [0, x, rx], [0, y, ry]]
    return d


def combine(l1, l2):
    if l1:
        if l2:
            l2__0 = l2[2]
            a2 = l2[1]
            l1__0 = l1[2]
            a1 = l1[1]
            return [0, [0, a1, a2], combine(l1__0, l2__0)]
    else:
        if not (l2):
            return 0
    return call1(Pervasives[1], cst_List_combine)


def merge(cmp, l1, match):
    if l1:
        if match:
            t2 = match[2]
            h2 = match[1]
            t1 = l1[2]
            h1 = l1[1]
            return (
                [0, h2, merge(cmp, l1, t2)]
                if 0 < call2(cmp, h1, h2)
                else [0, h1, merge(cmp, t1, match)]
            )
        return l1
    return match


def chop(k, l):
    k__0 = k
    l__0 = l
    while True:
        if 0 is k__0:
            return l__0
        if l__0:
            l__1 = l__0[2]
            k__1 = int(k__0 + -1)
            k__0 = k__1
            l__0 = l__1
            continue
        raise (empty["caml_wrap_thrown_exception"]([0, Assert_failure, e]))


def stable_sort(cmp, l):
    def rev_merge(l1, l2, accu):
        l1__0 = l1
        l2__0 = l2
        accu__0 = accu
        while True:
            if l1__0:
                if l2__0:
                    t2 = l2__0[2]
                    h2 = l2__0[1]
                    t1 = l1__0[2]
                    h1 = l1__0[1]
                    if 0 < call2(cmp, h1, h2):
                        accu__1 = [0, h2, accu__0]
                        l2__0 = t2
                        accu__0 = accu__1
                        continue
                    accu__2 = [0, h1, accu__0]
                    l1__0 = t1
                    accu__0 = accu__2
                    continue
                return rev_append(l1__0, accu__0)
            return rev_append(l2__0, accu__0)

    def rev_merge_rev(l1, l2, accu):
        l1__0 = l1
        l2__0 = l2
        accu__0 = accu
        while True:
            if l1__0:
                if l2__0:
                    t2 = l2__0[2]
                    h2 = l2__0[1]
                    t1 = l1__0[2]
                    h1 = l1__0[1]
                    if 0 < call2(cmp, h1, h2):
                        accu__1 = [0, h1, accu__0]
                        l1__0 = t1
                        accu__0 = accu__1
                        continue
                    accu__2 = [0, h2, accu__0]
                    l2__0 = t2
                    accu__0 = accu__2
                    continue
                return rev_append(l1__0, accu__0)
            return rev_append(l2__0, accu__0)

    def sort(n, l):
        if 2 is n:
            if l:
                o = l[2]
                if o:
                    x2 = o[1]
                    x1 = l[1]
                    return (
                        [0, x2, [0, x1, 0]]
                        if 0 < call2(cmp, x1, x2)
                        else [0, x1, [0, x2, 0]]
                    )
        else:
            if 3 is n:
                if l:
                    p = l[2]
                    if p:
                        q = p[2]
                        if q:
                            x3 = q[1]
                            x2__0 = p[1]
                            x1__0 = l[1]
                            return (
                                (
                                    (
                                        [0, x3, [0, x2__0, [0, x1__0, 0]]]
                                        if 0 < call2(cmp, x2__0, x3)
                                        else [0, x2__0, [0, x3, [0, x1__0, 0]]]
                                    )
                                    if 0 < call2(cmp, x1__0, x3)
                                    else [0, x2__0, [0, x1__0, [0, x3, 0]]]
                                )
                                if 0 < call2(cmp, x1__0, x2__0)
                                else (
                                    (
                                        [0, x3, [0, x1__0, [0, x2__0, 0]]]
                                        if 0 < call2(cmp, x1__0, x3)
                                        else [0, x1__0, [0, x3, [0, x2__0, 0]]]
                                    )
                                    if 0 < call2(cmp, x2__0, x3)
                                    else [0, x1__0, [0, x2__0, [0, x3, 0]]]
                                )
                            )
        n1 = asr(n, 1)
        n2 = int(n - n1)
        l2 = chop(n1, l)
        s1 = rev_sort(n1, l)
        s2 = rev_sort(n2, l2)
        return rev_merge_rev(s1, s2, 0)

    def rev_sort(n, l):
        if 2 is n:
            if l:
                l = l[2]
                if l:
                    x2 = l[1]
                    x1 = l[1]
                    return (
                        [0, x1, [0, x2, 0]]
                        if 0 < call2(cmp, x1, x2)
                        else [0, x2, [0, x1, 0]]
                    )
        else:
            if 3 is n:
                if l:
                    m = l[2]
                    if m:
                        n = m[2]
                        if n:
                            x3 = n[1]
                            x2__0 = m[1]
                            x1__0 = l[1]
                            return (
                                (
                                    [0, x1__0, [0, x2__0, [0, x3, 0]]]
                                    if 0 < call2(cmp, x2__0, x3)
                                    else (
                                        [0, x1__0, [0, x3, [0, x2__0, 0]]]
                                        if 0 < call2(cmp, x1__0, x3)
                                        else [0, x3, [0, x1__0, [0, x2__0, 0]]]
                                    )
                                )
                                if 0 < call2(cmp, x1__0, x2__0)
                                else (
                                    [0, x2__0, [0, x1__0, [0, x3, 0]]]
                                    if 0 < call2(cmp, x1__0, x3)
                                    else (
                                        [0, x2__0, [0, x3, [0, x1__0, 0]]]
                                        if 0 < call2(cmp, x2__0, x3)
                                        else [0, x3, [0, x2__0, [0, x1__0, 0]]]
                                    )
                                )
                            )
        n1 = asr(n, 1)
        n2 = int(n - n1)
        l2 = chop(n1, l)
        s1 = sort(n1, l)
        s2 = sort(n2, l2)
        return rev_merge(s1, s2, 0)

    len = length(l)
    return sort(len, l) if 2 <= len else l


def sort_uniq(cmp, l):
    def rev_merge(l1, l2, accu):
        l1__0 = l1
        l2__0 = l2
        accu__0 = accu
        while True:
            if l1__0:
                if l2__0:
                    t2 = l2__0[2]
                    h2 = l2__0[1]
                    t1 = l1__0[2]
                    h1 = l1__0[1]
                    c = call2(cmp, h1, h2)
                    if 0 is c:
                        accu__1 = [0, h1, accu__0]
                        l1__0 = t1
                        l2__0 = t2
                        accu__0 = accu__1
                        continue
                    if 0 <= c:
                        accu__2 = [0, h2, accu__0]
                        l2__0 = t2
                        accu__0 = accu__2
                        continue
                    accu__3 = [0, h1, accu__0]
                    l1__0 = t1
                    accu__0 = accu__3
                    continue
                return rev_append(l1__0, accu__0)
            return rev_append(l2__0, accu__0)

    def rev_merge_rev(l1, l2, accu):
        l1__0 = l1
        l2__0 = l2
        accu__0 = accu
        while True:
            if l1__0:
                if l2__0:
                    t2 = l2__0[2]
                    h2 = l2__0[1]
                    t1 = l1__0[2]
                    h1 = l1__0[1]
                    c = call2(cmp, h1, h2)
                    if 0 is c:
                        accu__1 = [0, h1, accu__0]
                        l1__0 = t1
                        l2__0 = t2
                        accu__0 = accu__1
                        continue
                    if 0 < c:
                        accu__2 = [0, h1, accu__0]
                        l1__0 = t1
                        accu__0 = accu__2
                        continue
                    accu__3 = [0, h2, accu__0]
                    l2__0 = t2
                    accu__0 = accu__3
                    continue
                return rev_append(l1__0, accu__0)
            return rev_append(l2__0, accu__0)

    def sort(n, l):
        if 2 is n:
            if l:
                i = l[2]
                if i:
                    x2 = i[1]
                    x1 = l[1]
                    c = call2(cmp, x1, x2)
                    return (
                        [0, x1, 0]
                        if 0 is c
                        else ([0, x2, [0, x1, 0]] if 0 <= c else [0, x1, [0, x2, 0]])
                    )
        else:
            if 3 is n:
                if l:
                    j = l[2]
                    if j:
                        k = j[2]
                        if k:
                            x3 = k[1]
                            x2__0 = j[1]
                            x1__0 = l[1]
                            c__0 = call2(cmp, x1__0, x2__0)
                            if 0 is c__0:
                                c__1 = call2(cmp, x2__0, x3)
                                return (
                                    [0, x2__0, 0]
                                    if 0 is c__1
                                    else (
                                        [0, x3, [0, x2__0, 0]]
                                        if 0 <= c__1
                                        else [0, x2__0, [0, x3, 0]]
                                    )
                                )
                            if 0 <= c__0:
                                c__2 = call2(cmp, x1__0, x3)
                                if 0 is c__2:
                                    return [0, x2__0, [0, x1__0, 0]]
                                if 0 <= c__2:
                                    c__3 = call2(cmp, x2__0, x3)
                                    return (
                                        [0, x2__0, [0, x1__0, 0]]
                                        if 0 is c__3
                                        else (
                                            [0, x3, [0, x2__0, [0, x1__0, 0]]]
                                            if 0 <= c__3
                                            else [0, x2__0, [0, x3, [0, x1__0, 0]]]
                                        )
                                    )
                                return [0, x2__0, [0, x1__0, [0, x3, 0]]]
                            c__4 = call2(cmp, x2__0, x3)
                            if 0 is c__4:
                                return [0, x1__0, [0, x2__0, 0]]
                            if 0 <= c__4:
                                c__5 = call2(cmp, x1__0, x3)
                                return (
                                    [0, x1__0, [0, x2__0, 0]]
                                    if 0 is c__5
                                    else (
                                        [0, x3, [0, x1__0, [0, x2__0, 0]]]
                                        if 0 <= c__5
                                        else [0, x1__0, [0, x3, [0, x2__0, 0]]]
                                    )
                                )
                            return [0, x1__0, [0, x2__0, [0, x3, 0]]]
        n1 = asr(n, 1)
        n2 = int(n - n1)
        l2 = chop(n1, l)
        s1 = rev_sort(n1, l)
        s2 = rev_sort(n2, l2)
        return rev_merge_rev(s1, s2, 0)

    def rev_sort(n, l):
        if 2 is n:
            if l:
                f = l[2]
                if f:
                    x2 = f[1]
                    x1 = l[1]
                    c = call2(cmp, x1, x2)
                    return (
                        [0, x1, 0]
                        if 0 is c
                        else ([0, x1, [0, x2, 0]] if 0 < c else [0, x2, [0, x1, 0]])
                    )
        else:
            if 3 is n:
                if l:
                    g = l[2]
                    if g:
                        h = g[2]
                        if h:
                            x3 = h[1]
                            x2__0 = g[1]
                            x1__0 = l[1]
                            c__0 = call2(cmp, x1__0, x2__0)
                            if 0 is c__0:
                                c__1 = call2(cmp, x2__0, x3)
                                return (
                                    [0, x2__0, 0]
                                    if 0 is c__1
                                    else (
                                        [0, x2__0, [0, x3, 0]]
                                        if 0 < c__1
                                        else [0, x3, [0, x2__0, 0]]
                                    )
                                )
                            if 0 < c__0:
                                c__2 = call2(cmp, x2__0, x3)
                                if 0 is c__2:
                                    return [0, x1__0, [0, x2__0, 0]]
                                if 0 < c__2:
                                    return [0, x1__0, [0, x2__0, [0, x3, 0]]]
                                c__3 = call2(cmp, x1__0, x3)
                                return (
                                    [0, x1__0, [0, x2__0, 0]]
                                    if 0 is c__3
                                    else (
                                        [0, x1__0, [0, x3, [0, x2__0, 0]]]
                                        if 0 < c__3
                                        else [0, x3, [0, x1__0, [0, x2__0, 0]]]
                                    )
                                )
                            c__4 = call2(cmp, x1__0, x3)
                            if 0 is c__4:
                                return [0, x2__0, [0, x1__0, 0]]
                            if 0 < c__4:
                                return [0, x2__0, [0, x1__0, [0, x3, 0]]]
                            c__5 = call2(cmp, x2__0, x3)
                            return (
                                [0, x2__0, [0, x1__0, 0]]
                                if 0 is c__5
                                else (
                                    [0, x2__0, [0, x3, [0, x1__0, 0]]]
                                    if 0 < c__5
                                    else [0, x3, [0, x2__0, [0, x1__0, 0]]]
                                )
                            )
        n1 = asr(n, 1)
        n2 = int(n - n1)
        l2 = chop(n1, l)
        s1 = sort(n1, l)
        s2 = sort(n2, l2)
        return rev_merge(s1, s2, 0)

    len = length(l)
    return sort(len, l) if 2 <= len else l


def compare_lengths(l1, l2):
    l1__0 = l1
    l2__0 = l2
    while True:
        if l1__0:
            if l2__0:
                l2__1 = l2__0[2]
                l1__1 = l1__0[2]
                l1__0 = l1__1
                l2__0 = l2__1
                continue
            return 1
        return -1 if l2__0 else 0


def compare_length_with(l, n):
    l__0 = l
    n__0 = n
    while True:
        if l__0:
            l__1 = l__0[2]
            if 0 < n__0:
                n__1 = int(n__0 + -1)
                l__0 = l__1
                n__0 = n__1
                continue
            return 1
        return 0 if 0 is n__0 else (-1 if 0 < n__0 else 1)


List = [
    0,
    length,
    compare_lengths,
    compare_length_with,
    cons,
    hd,
    tl,
    nth,
    nth_opt,
    rev,
    init,
    append,
    rev_append,
    flatten,
    flatten,
    iter,
    iteri,
    map,
    mapi,
    rev_map,
    fold_left,
    fold_right,
    iter2,
    map2,
    rev_map2,
    fold_left2,
    fold_right2,
    for_all,
    exists,
    for_all2,
    exists2,
    mem,
    memq,
    find,
    find_opt,
    find_all,
    find_all,
    partition,
    assoc,
    assoc_opt,
    assq,
    assq_opt,
    mem_assoc,
    mem_assq,
    remove_assoc,
    remove_assq,
    split,
    combine,
    stable_sort,
    stable_sort,
    stable_sort,
    sort_uniq,
    merge,
]
empty["caml_register_global"](19, List, "List_")
