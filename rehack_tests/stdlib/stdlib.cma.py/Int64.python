caml_wrap_exception = empty["caml_wrap_exception"]
global_data = empty["caml_get_global_data"]()
cst_d = empty["caml_new_string"]("%d")
zero = [255, 0, 0, 0]
one = [255, 1, 0, 0]
minus_one = [255, 16777215, 16777215, 65535]
min_int = [255, 0, 0, 32768]
max_int = [255, 16777215, 16777215, 32767]
Failure = global_data["Failure"]
e = [255, 16777215, 16777215, 65535]
d = [255, 0, 0, 0]
c = [255, 1, 0, 0]
b = [255, 1, 0, 0]


def succ(n):
    return empty["caml_int64_add"](n, b)


def pred(n):
    return empty["caml_int64_sub"](n, c)


def abs(n):
    return n if empty["caml_greaterequal"](n, d) else empty["caml_int64_neg"](n)


def lognot(n):
    return empty["caml_int64_xor"](n, e)


def to_string(n):
    return empty["caml_int64_format"](cst_d, n)


def of_string_opt(s):
    try:
        f = [0, empty["caml_int64_of_string"](s)]
        return f
    except Exception as g:
        g = caml_wrap_exception(g)
        if g[1] is Failure:
            return 0
        raise (empty["caml_wrap_thrown_exception_reraise"](g))


def compare(x, y):
    return empty["caml_int64_compare"](x, y)


def equal(x, y):
    return 1 if 0 is compare(x, y) else 0


Int64 = [
    0,
    zero,
    one,
    minus_one,
    succ,
    pred,
    abs,
    max_int,
    min_int,
    lognot,
    of_string_opt,
    to_string,
    compare,
    equal,
]
empty["caml_register_global"](11, Int64, "Int64")
