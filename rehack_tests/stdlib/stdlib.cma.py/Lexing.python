caml_bytes_get = empty["caml_bytes_get"]
caml_check_bound = empty["caml_check_bound"]
caml_create_bytes = empty["caml_create_bytes"]
caml_ml_bytes_length = empty["caml_ml_bytes_length"]
string = empty["caml_new_string"]


def call1(f, a0):
    return f(a0) if arity_test is 1 else empty["caml_call_gen"](f, [a0])


def call2(f, a0, a1):
    return f(a0, a1) if arity_test is 2 else empty["caml_call_gen"](f, [a0, a1])


def call3(f, a0, a1, a2):
    return f(a0, a1, a2) if arity_test is 3 else empty["caml_call_gen"](f, [a0, a1, a2])


def call4(f, a0, a1, a2, a3):
    return (
        f(a0, a1, a2, a3)
        if arity_test is 4
        else empty["caml_call_gen"](f, [a0, a1, a2, a3])
    )


def call5(f, a0, a1, a2, a3, a4):
    return (
        f(a0, a1, a2, a3, a4)
        if arity_test is 5
        else empty["caml_call_gen"](f, [a0, a1, a2, a3, a4])
    )


global_data = empty["caml_get_global_data"]()
cst_Lexing_lex_refill_cannot_grow_buffer = string(
    "Lexing.lex_refill: cannot grow buffer"
)
dummy_pos = [0, string(""), 0, 0, -1]
zero_pos = [0, string(""), 1, 0, 0]
Bytes = global_data["Bytes"]
Pervasives = global_data["Pervasives"]
Sys = global_data["Sys"]


def engine(tbl, state, buf):
    result = empty["caml_lex_engine"](tbl, state, buf)
    if 0 <= result:
        buf[11] = buf[12]
        A = buf[12]
        buf[12] = [0, A[1], A[2], A[3], int(buf[4] + buf[6])]
    return result


def new_engine(tbl, state, buf):
    result = empty["caml_new_lex_engine"](tbl, state, buf)
    if 0 <= result:
        buf[11] = buf[12]
        z = buf[12]
        buf[12] = [0, z[1], z[2], z[3], int(buf[4] + buf[6])]
    return result


def lex_refill(read_fun, aux_buffer, lexbuf):
    read = call2(read_fun, aux_buffer, caml_ml_bytes_length(aux_buffer))
    n = read if 0 < read else (0 if UnsupportedAssignOp or true else 0)
    if caml_ml_bytes_length(lexbuf[2]) < int(lexbuf[3] + n):
        if int(int(lexbuf[3] - lexbuf[5]) + n) <= caml_ml_bytes_length(lexbuf[2]):
            call5(
                Bytes[11],
                lexbuf[2],
                lexbuf[5],
                lexbuf[2],
                0,
                int(lexbuf[3] - lexbuf[5]),
            )
        else:
            newlen = call2(
                Pervasives[4], int(2 * caml_ml_bytes_length(lexbuf[2])), Sys[13]
            )
            if newlen < int(int(lexbuf[3] - lexbuf[5]) + n):
                call1(Pervasives[2], cst_Lexing_lex_refill_cannot_grow_buffer)
            newbuf = caml_create_bytes(newlen)
            call5(
                Bytes[11], lexbuf[2], lexbuf[5], newbuf, 0, int(lexbuf[3] - lexbuf[5])
            )
            lexbuf[2] = newbuf
        s = lexbuf[5]
        lexbuf[4] = int(lexbuf[4] + s)
        lexbuf[6] = int(lexbuf[6] - s)
        lexbuf[5] = 0
        lexbuf[7] = int(lexbuf[7] - s)
        lexbuf[3] = int(lexbuf[3] - s)
        t = lexbuf[10]
        x = int(len(t) + -1)
        w = 0
        if not (x < 0):
            i = w
            while True:
                v = caml_check_bound(t, i)[i + 1]
                if 0 <= v:
                    caml_check_bound(t, i)[i + 1] = int(v - s)
                y = int(i + 1)
                if x is not i:
                    i = y
                    continue
                break
    call5(Bytes[11], aux_buffer, 0, lexbuf[2], lexbuf[3], n)
    lexbuf[3] = int(lexbuf[3] + n)
    return 0


def from_function(f):
    l = [0]
    m = 0
    n = 0
    o = 0
    p = 0
    q = 0
    r = 0
    s = 0
    t = caml_create_bytes(1024)
    u = caml_create_bytes(512)

    def function_expression_15(v):
        return lex_refill(f, u, v)

    return [0, function_expression_15, t, s, r, q, p, o, n, m, l, zero_pos, zero_pos]


def from_channel(ic):
    def function_expression_16(buf, n):
        return call4(Pervasives[72], ic, buf, 0, n)

    return from_function(function_expression_16)


def from_string(s):
    c = [0]
    d = 1
    e = 0
    f = 0
    g = 0
    h = 0
    i = 0
    j = empty["caml_ml_string_length"](s)
    k = call1(Bytes[5], s)

    def function_expression_17(lexbuf):
        lexbuf[9] = 1
        return 0

    return [0, function_expression_17, k, j, i, h, g, f, e, d, c, zero_pos, zero_pos]


def lexeme(lexbuf):
    len = int(lexbuf[6] - lexbuf[5])
    return call3(Bytes[8], lexbuf[2], lexbuf[5], len)


def sub_lexeme(lexbuf, i1, i2):
    len = int(i2 - i1)
    return call3(Bytes[8], lexbuf[2], i1, len)


def sub_lexeme_opt(lexbuf, i1, i2):
    if 0 <= i1:
        len = int(i2 - i1)
        return [0, call3(Bytes[8], lexbuf[2], i1, len)]
    return 0


def sub_lexeme_char(lexbuf, i):
    return caml_bytes_get(lexbuf[2], i)


def sub_lexeme_char_opt(lexbuf, i):
    return [0, caml_bytes_get(lexbuf[2], i)] if 0 <= i else 0


def lexeme_char(lexbuf, i):
    return caml_bytes_get(lexbuf[2], int(lexbuf[5] + i))


def lexeme_start(lexbuf):
    return lexbuf[11][4]


def lexeme_end(lexbuf):
    return lexbuf[12][4]


def lexeme_start_p(lexbuf):
    return lexbuf[11]


def lexeme_end_p(lexbuf):
    return lexbuf[12]


def new_line(lexbuf):
    lcp = lexbuf[12]
    lexbuf[12] = [0, lcp[1], int(lcp[2] + 1), lcp[4], lcp[4]]
    return 0


def flush_input(lb):
    lb[6] = 0
    lb[4] = 0
    b = lb[12]
    lb[12] = [0, b[1], b[2], b[3], 0]
    lb[3] = 0
    return 0


Lexing = [
    0,
    dummy_pos,
    from_channel,
    from_string,
    from_function,
    lexeme,
    lexeme_char,
    lexeme_start,
    lexeme_end,
    lexeme_start_p,
    lexeme_end_p,
    new_line,
    flush_input,
    sub_lexeme,
    sub_lexeme_opt,
    sub_lexeme_char,
    sub_lexeme_char_opt,
    engine,
    new_engine,
]
empty["caml_register_global"](6, Lexing, "Lexing")
