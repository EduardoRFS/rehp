caml_blit_bytes = empty["caml_blit_bytes"]
caml_bytes_unsafe_get = empty["caml_bytes_unsafe_get"]
caml_bytes_unsafe_set = empty["caml_bytes_unsafe_set"]
caml_create_bytes = empty["caml_create_bytes"]
caml_fill_bytes = empty["caml_fill_bytes"]
caml_ml_bytes_length = empty["caml_ml_bytes_length"]
string = empty["caml_new_string"]
caml_wrap_exception = empty["caml_wrap_exception"]


def call1(f, a0):
    return f(a0) if arity_test is 1 else empty["caml_call_gen"](f, [a0])


def call2(f, a0, a1):
    return f(a0, a1) if arity_test is 2 else empty["caml_call_gen"](f, [a0, a1])


global_data = empty["caml_get_global_data"]()
cst_String_rcontains_from_Bytes_rcontains_from = string(
    "String.rcontains_from / Bytes.rcontains_from"
)
cst_String_contains_from_Bytes_contains_from = string(
    "String.contains_from / Bytes.contains_from"
)
cst_String_rindex_from_opt_Bytes_rindex_from_opt = string(
    "String.rindex_from_opt / Bytes.rindex_from_opt"
)
cst_String_rindex_from_Bytes_rindex_from = string(
    "String.rindex_from / Bytes.rindex_from"
)
cst_String_index_from_opt_Bytes_index_from_opt = string(
    "String.index_from_opt / Bytes.index_from_opt"
)
cst_String_index_from_Bytes_index_from = string("String.index_from / Bytes.index_from")
cst_Bytes_concat = string("Bytes.concat")
cst_String_blit_Bytes_blit_string = string("String.blit / Bytes.blit_string")
cst_Bytes_blit = string("Bytes.blit")
cst_String_fill_Bytes_fill = string("String.fill / Bytes.fill")
cst_Bytes_extend = string("Bytes.extend")
cst_String_sub_Bytes_sub = string("String.sub / Bytes.sub")
Not_found = global_data["Not_found"]
Char = global_data["Char"]
Pervasives = global_data["Pervasives"]


def make(n, c):
    s = caml_create_bytes(n)
    caml_fill_bytes(s, 0, n, c)
    return s


def init(n, f):
    s = caml_create_bytes(n)
    O = int(n + -1)
    N = 0
    if not (O < 0):
        i = N
        while True:
            caml_bytes_unsafe_set(s, i, call1(f, i))
            P = int(i + 1)
            if O is not i:
                i = P
                continue
            break
    return s


empty = caml_create_bytes(0)


def copy(s):
    len = caml_ml_bytes_length(s)
    r = caml_create_bytes(len)
    caml_blit_bytes(s, 0, r, 0, len)
    return r


def to_string(b):
    return copy(b)


def of_string(s):
    return copy(s)


def sub(s, ofs, len):
    if 0 <= ofs:
        if 0 <= len:
            if not (int(caml_ml_bytes_length(s) - len) < ofs):
                r = caml_create_bytes(len)
                caml_blit_bytes(s, ofs, r, 0, len)
                return r
    return call1(Pervasives[1], cst_String_sub_Bytes_sub)


def sub_string(b, ofs, len):
    return sub(b, ofs, len)


def symbol(a, b):
    c = int(a + b)
    M = 1 if b < 0 else 0
    match = 1 if c < 0 else 0
    switch__0 = (
        ((0 if 0 is match else 1) if 0 is M else 0)
        if 0 is (1 if a < 0 else 0)
        else (0 if 0 is M else (1 if 0 is match else 0))
    )
    return call1(Pervasives[1], cst_Bytes_extend) if switch__0 else c


def extend(s, left, right):
    len = symbol(symbol(caml_ml_bytes_length(s), left), right)
    r = caml_create_bytes(len)
    if 0 <= left:
        srcoff = 0
        srcoff__0 = srcoff
        dstoff = left
    else:
        K = 0
        L = int(-(left))
        srcoff__0 = L
        dstoff = K
    cpylen = call2(
        Pervasives[4], int(caml_ml_bytes_length(s) - srcoff__0), int(len - dstoff)
    )
    if 0 < cpylen:
        caml_blit_bytes(s, srcoff__0, r, dstoff, cpylen)
    return r


def fill(s, ofs, len, c):
    if 0 <= ofs:
        if 0 <= len:
            if not (int(caml_ml_bytes_length(s) - len) < ofs):
                return caml_fill_bytes(s, ofs, len, c)
    return call1(Pervasives[1], cst_String_fill_Bytes_fill)


def blit(s1, ofs1, s2, ofs2, len):
    if 0 <= len:
        if 0 <= ofs1:
            if not (int(caml_ml_bytes_length(s1) - len) < ofs1):
                if 0 <= ofs2:
                    if not (int(caml_ml_bytes_length(s2) - len) < ofs2):
                        return caml_blit_bytes(s1, ofs1, s2, ofs2, len)
    return call1(Pervasives[1], cst_Bytes_blit)


def blit_string(s1, ofs1, s2, ofs2, len):
    if 0 <= len:
        if 0 <= ofs1:
            if not (int(empty["caml_ml_string_length"](s1) - len) < ofs1):
                if 0 <= ofs2:
                    if not (int(caml_ml_bytes_length(s2) - len) < ofs2):
                        return empty["caml_blit_string"](s1, ofs1, s2, ofs2, len)
    return call1(Pervasives[1], cst_String_blit_Bytes_blit_string)


def iter(f, a):
    I = int(caml_ml_bytes_length(a) + -1)
    H = 0
    if not (I < 0):
        i = H
        while True:
            call1(f, caml_bytes_unsafe_get(a, i))
            J = int(i + 1)
            if I is not i:
                i = J
                continue
            break
    return 0


def iteri(f, a):
    F = int(caml_ml_bytes_length(a) + -1)
    E = 0
    if not (F < 0):
        i = E
        while True:
            call2(f, i, caml_bytes_unsafe_get(a, i))
            G = int(i + 1)
            if F is not i:
                i = G
                continue
            break
    return 0


def ensure_ge(x, y):
    return x if y <= x else call1(Pervasives[1], cst_Bytes_concat)


def sum_lengths(acc, seplen, param):
    acc__0 = acc
    param__0 = param
    while True:
        if param__0:
            C = param__0[2]
            D = param__0[1]
            if C:
                acc__1 = ensure_ge(
                    int(int(caml_ml_bytes_length(D) + seplen) + acc__0), acc__0
                )
                acc__0 = acc__1
                param__0 = C
                continue
            return int(caml_ml_bytes_length(D) + acc__0)
        return acc__0


def unsafe_blits(dst, pos, sep, seplen, param):
    pos__0 = pos
    param__0 = param
    while True:
        if param__0:
            A = param__0[2]
            B = param__0[1]
            if A:
                caml_blit_bytes(B, 0, dst, pos__0, caml_ml_bytes_length(B))
                caml_blit_bytes(
                    sep, 0, dst, int(pos__0 + caml_ml_bytes_length(B)), seplen
                )
                pos__1 = int(int(pos__0 + caml_ml_bytes_length(B)) + seplen)
                pos__0 = pos__1
                param__0 = A
                continue
            caml_blit_bytes(B, 0, dst, pos__0, caml_ml_bytes_length(B))
            return dst
        return dst


def concat(sep, l):
    if l:
        seplen = caml_ml_bytes_length(sep)
        return unsafe_blits(
            caml_create_bytes(sum_lengths(0, seplen, l)), 0, sep, seplen, l
        )
    return empty


def cat(s1, s2):
    l1 = caml_ml_bytes_length(s1)
    l2 = caml_ml_bytes_length(s2)
    r = caml_create_bytes(int(l1 + l2))
    caml_blit_bytes(s1, 0, r, 0, l1)
    caml_blit_bytes(s2, 0, r, l1, l2)
    return r


def is_space(param):
    z = int(param + -9)
    switch__0 = (1 if 23 is z else 0) if 4 < lsr(z, 0) else (0 if 2 is z else 1)
    return 1 if switch__0 else 0


def trim(s):
    len = caml_ml_bytes_length(s)
    i = [0, 0]
    while True:
        if i[1] < len:
            if is_space(caml_bytes_unsafe_get(s, i[1])):
                i[1] += 1
                continue
        j = [0, int(len + -1)]
        while True:
            if i[1] <= j[1]:
                if is_space(caml_bytes_unsafe_get(s, j[1])):
                    j[1] += -1
                    continue
            return sub(s, i[1], int(int(j[1] - i[1]) + 1)) if i[1] <= j[1] else empty


def escaped(s):
    n = [0, 0]
    s = int(caml_ml_bytes_length(s) + -1)
    r = 0
    if not (s < 0):
        i__0 = r
        while True:
            match = caml_bytes_unsafe_get(s, i__0)
            if 32 <= match:
                w = int(match + -34)
                if 58 < lsr(w, 0):
                    if 93 <= w:
                        switch__0 = 0
                        switch__1 = 0
                    else:
                        switch__1 = 1
                else:
                    if 56 < lsr(int(w + -1), 0):
                        switch__0 = 1
                        switch__1 = 0
                    else:
                        switch__1 = 1
                if switch__1:
                    x = 1
                    switch__0 = 2
            else:
                switch__0 = (
                    (1 if 13 is match else 0)
                    if 11 <= match
                    else (1 if 8 <= match else 0)
                )
            while True:
                if switch__0 is 0:
                    x = 4
                    break
                else:
                    if switch__0 is 1:
                        x = 2
                        break
                break
            n[1] = int(n[1] + x)
            y = int(i__0 + 1)
            if s is not i__0:
                i__0 = y
                continue
            break
    if n[1] is caml_ml_bytes_length(s):
        return copy(s)
    s__0 = caml_create_bytes(n[1])
    n[1] = 0
    u = int(caml_ml_bytes_length(s) + -1)
    t = 0
    if not (u < 0):
        i = t
        while True:
            c = caml_bytes_unsafe_get(s, i)
            if 35 <= c:
                switch__2 = 1 if 92 is c else (0 if 127 <= c else 2)
            else:
                if 32 <= c:
                    switch__2 = 1 if 34 <= c else 2
                else:
                    if 14 <= c:
                        switch__2 = 0
                    else:
                        while True:
                            if c is 8:
                                caml_bytes_unsafe_set(s__0, n[1], 92)
                                n[1] += 1
                                caml_bytes_unsafe_set(s__0, n[1], 98)
                                switch__2 = 3
                                break
                            else:
                                if c is 9:
                                    caml_bytes_unsafe_set(s__0, n[1], 92)
                                    n[1] += 1
                                    caml_bytes_unsafe_set(s__0, n[1], 116)
                                    switch__2 = 3
                                    break
                                else:
                                    if c is 10:
                                        caml_bytes_unsafe_set(s__0, n[1], 92)
                                        n[1] += 1
                                        caml_bytes_unsafe_set(s__0, n[1], 110)
                                        switch__2 = 3
                                        break
                                    else:
                                        if c is 13:
                                            caml_bytes_unsafe_set(s__0, n[1], 92)
                                            n[1] += 1
                                            caml_bytes_unsafe_set(s__0, n[1], 114)
                                            switch__2 = 3
                                            break
                                        else:
                                            switch__2 = 0
                            break
            while True:
                if switch__2 is 0:
                    caml_bytes_unsafe_set(s__0, n[1], 92)
                    n[1] += 1
                    caml_bytes_unsafe_set(s__0, n[1], int(48 + int(c / 100)))
                    n[1] += 1
                    caml_bytes_unsafe_set(s__0, n[1], int(48 + int(int(c / 10) % 10)))
                    n[1] += 1
                    caml_bytes_unsafe_set(s__0, n[1], int(48 + int(c % 10)))
                    break
                else:
                    if switch__2 is 1:
                        caml_bytes_unsafe_set(s__0, n[1], 92)
                        n[1] += 1
                        caml_bytes_unsafe_set(s__0, n[1], c)
                        break
                    else:
                        if switch__2 is 2:
                            caml_bytes_unsafe_set(s__0, n[1], c)
                            break
                break
            n[1] += 1
            v = int(i + 1)
            if u is not i:
                i = v
                continue
            break
    return s__0


def map(f, s):
    l = caml_ml_bytes_length(s)
    if 0 is l:
        return s
    r = caml_create_bytes(l)
    p = int(l + -1)
    o = 0
    if not (p < 0):
        i = o
        while True:
            caml_bytes_unsafe_set(r, i, call1(f, caml_bytes_unsafe_get(s, i)))
            q = int(i + 1)
            if p is not i:
                i = q
                continue
            break
    return r


def mapi(f, s):
    l = caml_ml_bytes_length(s)
    if 0 is l:
        return s
    r = caml_create_bytes(l)
    m = int(l + -1)
    l = 0
    if not (m < 0):
        i = l
        while True:
            caml_bytes_unsafe_set(r, i, call2(f, i, caml_bytes_unsafe_get(s, i)))
            n = int(i + 1)
            if m is not i:
                i = n
                continue
            break
    return r


def uppercase_ascii(s):
    return map(Char[6], s)


def lowercase_ascii(s):
    return map(Char[5], s)


def apply1(f, s):
    if 0 is caml_ml_bytes_length(s):
        return s
    r = copy(s)
    caml_bytes_unsafe_set(r, 0, call1(f, caml_bytes_unsafe_get(s, 0)))
    return r


def capitalize_ascii(s):
    return apply1(Char[6], s)


def uncapitalize_ascii(s):
    return apply1(Char[5], s)


def index_rec(s, lim, i, c):
    i__0 = i
    while True:
        if lim <= i__0:
            raise (empty["caml_wrap_thrown_exception"](Not_found))
        if caml_bytes_unsafe_get(s, i__0) is c:
            return i__0
        i__1 = int(i__0 + 1)
        i__0 = i__1
        continue


def index(s, c):
    return index_rec(s, caml_ml_bytes_length(s), 0, c)


def index_rec_opt(s, lim, i, c):
    i__0 = i
    while True:
        if lim <= i__0:
            return 0
        if caml_bytes_unsafe_get(s, i__0) is c:
            return [0, i__0]
        i__1 = int(i__0 + 1)
        i__0 = i__1
        continue


def index_opt(s, c):
    return index_rec_opt(s, caml_ml_bytes_length(s), 0, c)


def index_from(s, i, c):
    l = caml_ml_bytes_length(s)
    if 0 <= i:
        if not (l < i):
            return index_rec(s, l, i, c)
    return call1(Pervasives[1], cst_String_index_from_Bytes_index_from)


def index_from_opt(s, i, c):
    l = caml_ml_bytes_length(s)
    if 0 <= i:
        if not (l < i):
            return index_rec_opt(s, l, i, c)
    return call1(Pervasives[1], cst_String_index_from_opt_Bytes_index_from_opt)


def rindex_rec(s, i, c):
    i__0 = i
    while True:
        if 0 <= i__0:
            if caml_bytes_unsafe_get(s, i__0) is c:
                return i__0
            i__1 = int(i__0 + -1)
            i__0 = i__1
            continue
        raise (empty["caml_wrap_thrown_exception"](Not_found))


def rindex(s, c):
    return rindex_rec(s, int(caml_ml_bytes_length(s) + -1), c)


def rindex_from(s, i, c):
    if -1 <= i:
        if not (caml_ml_bytes_length(s) <= i):
            return rindex_rec(s, i, c)
    return call1(Pervasives[1], cst_String_rindex_from_Bytes_rindex_from)


def rindex_rec_opt(s, i, c):
    i__0 = i
    while True:
        if 0 <= i__0:
            if caml_bytes_unsafe_get(s, i__0) is c:
                return [0, i__0]
            i__1 = int(i__0 + -1)
            i__0 = i__1
            continue
        return 0


def rindex_opt(s, c):
    return rindex_rec_opt(s, int(caml_ml_bytes_length(s) + -1), c)


def rindex_from_opt(s, i, c):
    if -1 <= i:
        if not (caml_ml_bytes_length(s) <= i):
            return rindex_rec_opt(s, i, c)
    return call1(Pervasives[1], cst_String_rindex_from_opt_Bytes_rindex_from_opt)


def contains_from(s, i, c):
    l = caml_ml_bytes_length(s)
    if 0 <= i:
        if not (l < i):
            try:
                index_rec(s, l, i, c)
                j = 1
                return j
            except:
                k = caml_wrap_exception(k)
                if k is Not_found:
                    return 0
                raise (empty["caml_wrap_thrown_exception_reraise"](k))
    return call1(Pervasives[1], cst_String_contains_from_Bytes_contains_from)


def contains(s, c):
    return contains_from(s, 0, c)


def rcontains_from(s, i, c):
    if 0 <= i:
        if not (caml_ml_bytes_length(s) <= i):
            try:
                rindex_rec(s, i, c)
                h = 1
                return h
            except:
                i = caml_wrap_exception(i)
                if i is Not_found:
                    return 0
                raise (empty["caml_wrap_thrown_exception_reraise"](i))
    return call1(Pervasives[1], cst_String_rcontains_from_Bytes_rcontains_from)


def compare(x, y):
    return empty["caml_bytes_compare"](x, y)


def uppercase(s):
    return map(Char[4], s)


def lowercase(s):
    return map(Char[3], s)


def capitalize(s):
    return apply1(Char[4], s)


def uncapitalize(s):
    return apply1(Char[3], s)


def b(g):
    return g


def c(f):
    return f


def function_expression_8(e, d):
    return empty["caml_bytes_equal"](e, d)


Bytes = [
    0,
    make,
    init,
    empty,
    copy,
    of_string,
    to_string,
    sub,
    sub_string,
    extend,
    fill,
    blit,
    blit_string,
    concat,
    cat,
    iter,
    iteri,
    map,
    mapi,
    trim,
    escaped,
    index,
    index_opt,
    rindex,
    rindex_opt,
    index_from,
    index_from_opt,
    rindex_from,
    rindex_from_opt,
    contains,
    contains_from,
    rcontains_from,
    uppercase,
    lowercase,
    capitalize,
    uncapitalize,
    uppercase_ascii,
    lowercase_ascii,
    capitalize_ascii,
    uncapitalize_ascii,
    compare,
    function_expression_8,
    c,
    b,
]
empty["caml_register_global"](15, Bytes, "Bytes")
